{"config":{"lang":["en","de"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-helmoro","title":"Welcome to Helmoro","text":"<p>Welcome to the official documentation of Helmoro, the Helbling mobile robot. Helmoro is an open-source robotic platform designed by Helbling Technik in Zurich, Switzerland. </p> <p>It is equipped with LiDAR sensors and depth cameras, and thus is able to navigate autonomously. Additionally, we implemented a ROS node that allows the robot to be controlled with a game controller.</p> <p>On this website, you will find a comprehensive guide designed to help you build your own mobile robot. </p> <p>Whether you are looking to get started with our software, interested in the technicalities of our hardware designs, or seeking detailed installation guides, you've come to the right place.</p> <p>The website is structured into Hardware Documentation and Software Documentation. </p> <p>In the Hardware section, you will find a complete list of materials, access to all CAD files, as well as the complete assembly instructions. </p> <p>In the Software section, you'll find a link to the repo containing all the source code as well as a complete guide on how to install and run all the packages. Additionally, we tried to explain the thoughts behind some of the algorithms.</p>"},{"location":"collaboration/","title":"Collaboration","text":"<p>This guide provides instructions for general collaboration across the entire project, as well as specific setup and contribution details for those working on the project documentation.</p>"},{"location":"collaboration/#general-collaboration-guidelines","title":"General Collaboration Guidelines","text":"<p>The HelMoRo project welcomes contributions in various forms: bug fixes, feature additions, and documentation improvements. Here\u2019s how you can contribute across any part of the project.</p>"},{"location":"collaboration/#1-report-or-identify-issues","title":"1. Report or Identify Issues","text":"<p>Start by identifying or reporting issues. Describe the problem or suggest enhancements comprehensively.</p> <ul> <li>Repository issues page: HelMoRo issues</li> <li>Feature Bucket: Select from existing tasks on our GitHub projects page: Feature Bucket</li> </ul>"},{"location":"collaboration/#2-clone-the-repository","title":"2. Clone the Repository","text":"<p>For direct contributions, clone the repository using SSH (recommended):</p> <pre><code>git clone git@github.com:Helbling-Technik/HelMoRo.git\n</code></pre> <p>If you prefer you can also fork it and then work on your own fork.</p>"},{"location":"collaboration/#3-create-a-branch","title":"3. Create a Branch","text":"<p>Create a new branch in your cloned repository for the specific issue you are addressing:</p> <pre><code>git checkout -b issue-number-description\n</code></pre>"},{"location":"collaboration/#4-make-changes","title":"4. Make Changes","text":"<p>Implement your fixes or enhancements within your branch. Keep your branch updated to avoid conflicts:</p> <pre><code>git fetch origin\ngit rebase origin/master\n</code></pre>"},{"location":"collaboration/#5-commit-and-push-changes","title":"5. Commit and Push Changes","text":"<p>Commit your changes with clear, descriptive commit messages:</p> <pre><code>git add .\ngit commit -m \"Detailed description of your changes\"\ngit push origin issue-number-description\n</code></pre>"},{"location":"collaboration/#6-submit-a-pull-request","title":"6. Submit a Pull Request","text":"<p>After pushing your changes, submit a pull request (PR) through GitHub, linking it back to the issue it resolves.</p>"},{"location":"collaboration/#7-participate-in-the-review-process","title":"7. Participate in the Review Process","text":"<p>Engage with the project maintainers during the PR review process and address any feedback  to facilitate the integration of your contributions.</p>"},{"location":"collaboration/#8-stay-involved","title":"8. Stay Involved","text":"<p>Continue contributing by addressing more issues, reviewing others' contributions, and participating in project discussions.</p>"},{"location":"collaboration/#contribution-to-documentation","title":"Contribution to Documentation","text":"<p>Before you start contributing to the documentation, you need to set up MkDocs, which is used to build and manage the project documentation.  You can find all the Information in the README.md</p>"},{"location":"description/","title":"Description","text":"<p>Explore the world of robotics with HelMoRo, a versatile four-wheeled robot designed by Helbling. With its user-friendly assembly process and state-of-the-art components, HelMoRo provides an exciting platform for robotics enthusiasts and professionals alike.</p> <p></p>"},{"location":"description/#key-features","title":"Key Features","text":"<ul> <li>Robust and Agile:  Built on a sturdy four-wheel chassis, its skid-steered navigation system with Roboclaw Motor Controllers offers ensures agile movement and precise control.</li> <li>Advanced Sensing:  Equipped with sensors including Slamtec RPlidar LIDAR and an Orbbec Astra Pro RGB-D Camera and an Adafruit BNO055 Absolut Orientation IMU Sensor, HelMoRo accurately perceives its surroundings to navigate and interact with its environment effectively.</li> <li>Powerful Computing: Powered by the Raspberry Pi 5 running Ubuntu 22.04, HelMoRo handles complex data processing, supporting a variety of machine learning applications.</li> </ul>"},{"location":"description/#capabilities","title":"Capabilities","text":"<ul> <li>Real-Time Monitoring: Streams video, map, and positional data for remote monitoring and analysis.</li> <li>Remote and Autonomous Control: Easily controlled via a remote joystick or capable of autonomous navigation through advanced sensors for precise movement and obstacle avoidance.</li> <li>Mapping and Detection: Performs both remote-controlled and autonomous mapping, allowing it to create detailed environmental maps. Additionally, HelMoRo can detect and autonomously handle objects.</li> </ul>"},{"location":"about/about/","title":"About","text":"<p>Helbling is a globally active engineering and innovation partner supporting deep-tech product development from early ideation to industrialization with over 500 engineering specialists. The passion for technology and problem-solving drives us to deliver cutting-edge products and services to our clients. Whether it's product design, prototyping, software development, or system integration, we excel in delivering high-quality solutions tailored to meet our clients' needs </p> Helbling Technik AG      Hohlstrasse 614      CH-8048 Z\u00fcrich      +41 44 438 17 01      info-htkz@helbling.ch"},{"location":"hardware/assembly_instructions/","title":"Assembly Instructions","text":"<p>Do you have all the parts listed in the Bill of Materials ready? Then let's get started! This guide works for both the HelMoRo ROS 1 variant equipped with a NVIDIA Jetson Nano or the ROS 2 variant equipped with a Raspberry Pi 5.</p>"},{"location":"hardware/assembly_instructions/#task-0-get-ready","title":"Task 0: Get Ready","text":"<p>Make sure you have the following tools at hand before you start assembling. </p> <p>Material</p> <ul> <li>Electronic components</li> <li>Generative parts (3D printed and laser-cut parts)</li> <li>Sheet Metals</li> <li>Fasteners</li> </ul> <p>Tools</p> <ul> <li>2 mm hex-head key</li> <li>2.5 mm hex-head key</li> <li>8 mm hex-head socket</li> <li>18 mm wrench </li> <li>Flat-head screwdriver</li> <li>TR9 Torx screwdriver</li> <li>Soldering equipment</li> </ul> <p>Skills</p> <ul> <li>Basic mechanical assembly skills</li> <li>Soldering (connecting cables)</li> </ul> <p>Time</p> <ul> <li>The estimated assembly time is 70 minutes.</li> </ul>"},{"location":"hardware/assembly_instructions/#task-1-wheel-assembly","title":"Task 1: Wheel assembly","text":"<p>Assembly Time</p> <p>5 minutes / wheel</p> <p>Tools needed</p> <ul> <li>2 mm hex-head key</li> <li>2.5 mm hex-head key</li> </ul>"},{"location":"hardware/assembly_instructions/#step-1-motor","title":"Step 1: Motor","text":"<p>Required Parts:</p> <ul> <li>1x HEL-04-01000-02 / Frame Mount (For first wheel only)</li> <li>1x HEL-06-01009-00  / Motor</li> <li>6x DIN 7984 - M3 x 8 --- 4.5N / Screw M3x8</li> </ul> <p></p> <p>Securely fix the motor into the frame mount using 6x M3x8 screws. The first motor should be attached where the frame mount does not allow for sliding in the motor (back right).</p>"},{"location":"hardware/assembly_instructions/#step-2-wheel-adapter","title":"Step 2: Wheel Adapter","text":"<p>Required Parts:</p> <ul> <li>1x HEL-06-01002-00 / Wheel Adapter</li> <li>1x DIN 7984 - M3 x 12 --- 10.5N / Screw M3x12 </li> </ul> <p></p> <p>Attach the wheel adapter to the motor assembly using 1x M3x12 screw. Tighten the screw where the flange is flattened to stop it from rotating.</p>"},{"location":"hardware/assembly_instructions/#step-3-wheel","title":"Step 3: Wheel","text":"<p>Required Parts:</p> <ul> <li>1x HEL-06-01000-00 / Wheel </li> <li>4x DIN 7984 - M3 x 8 --- 6.5N / Screw M3x8 </li> </ul> <p></p> <p>Fix the wheel onto the wheel adapter using 4x M3x8 screws.</p> <p>Good job! Now 3 more to go.</p> <p></p> <p>This is how the assembly should look after all the wheels have been attached.</p>"},{"location":"hardware/assembly_instructions/#task-2-chassis","title":"Task 2: Chassis","text":"<p>Assembly Time</p> <p>30 minutes</p> <p>Tools needed</p> <ul> <li>2 mm hex-head key</li> <li>2.5 mm hex-head key</li> <li>Flat-head screwdriver</li> <li>TR9 Torx screwdriver</li> <li>8 mm hex-head socket</li> </ul>"},{"location":"hardware/assembly_instructions/#step-1-motor-controller-plate","title":"Step 1: Motor Controller Plate","text":"<p>Required Parts:</p> <ul> <li>1x HEL-04-01009-01 / Motor Controller Plate</li> <li>1x HEL-04-01010-01 / Top Plate</li> <li>2x ISO 4762 M3x4 / Screw M3x4</li> </ul> <p></p> <p>Attach the motor controller plate to the top plate using 2x M3x4 screws.</p>"},{"location":"hardware/assembly_instructions/#step-2-imu","title":"Step 2: IMU","text":"<p>Required Parts:</p> <ul> <li>1x HEL-06-03003-00 / IMU</li> <li>4x ISO 4762 M2 x 6 - 6N / Screw M2x6</li> <li>4x Washer ISO 7092 \u2013 2 / Washer M2</li> </ul> <p></p> <p>Mount the IMU using 4x M2x6 screws and 4x M2 washers.</p>"},{"location":"hardware/assembly_instructions/#step-3-top-plate-on-frame-mount","title":"Step 3: Top Plate on Frame Mount","text":"<p>Required Parts:</p> <ul> <li>4x DIN 7984 - M3 x 8 --- 6.5N / Screw M3x8</li> </ul> <p></p> <p>Secure the top plate to the frame mount using 4x M3x8 screws.</p>"},{"location":"hardware/assembly_instructions/#step-4-fan-on-jetson-skip-when-using-the-raspberry-pi","title":"Step 4: Fan on Jetson (skip when using the Raspberry Pi)","text":"<p>Required Parts:</p> <ul> <li>1x HEL-06-01005-00 / Fan</li> <li>1x HEL-06-01003-00 / Jetson</li> <li>4x ISO 14581 M2.5x16x16- / Screw M2.5x16</li> <li>4x ISO - 4032 - M2.5 - D \u2013 N / Nut M2.5</li> </ul> <p></p> <p>In order to provide some cooling, install the fan on the Jetson using 4x M2.5x16 screws and 4x M2.5 nuts.</p>"},{"location":"hardware/assembly_instructions/#step-5-mount-computer-on-top-plate","title":"Step 5: Mount Computer on Top Plate","text":"<p>Required Parts:</p> <ul> <li>1x HEL-04-03004-00 / Base Plate</li> <li>4x DIN 7984 - M3 x 8 --- 6.5N / Screw M3x8</li> </ul> <p></p> <p>Place the Base plate onto the Top Plate. Put the computer (Jetson Nano or Raspberry Pi 5) onto its base plate and attach both to the Top Plate using 4x M3x8 screws.</p>"},{"location":"hardware/assembly_instructions/#step-6-mount-motor-controller","title":"Step 6: Mount Motor Controller","text":"<p>Required Parts:</p> <ul> <li>2x HEL-06-01004-00 / Motor Controller Kit</li> <li>8x Screw from Motor Controller Kit</li> <li>1x HEL-04-01017-01 /  Holder Motorcontroller</li> </ul> <p></p> <p>Mount the first Motor Controller and the orange Motor Controller holder using the screws provided in the Motor Controller Kit. Attach the second Motor Controller on the Motor Controller Holder.</p>"},{"location":"hardware/assembly_instructions/#step-7-connect-cables","title":"Step 7: Connect Cables","text":"<p>Required Parts:</p> <ul> <li>2x HEL-06-03005-00 / USB Cable</li> </ul> <p></p> <p>Connect the USB cables as shown in the image and the Electronic System Architecture. Make sure that the encoder is connected to the right motor.</p>"},{"location":"hardware/assembly_instructions/#step-8-battery-protection","title":"Step 8: Battery Protection","text":"<p>Required Parts:</p> <ul> <li>1x HEL-06-04001-00 / Battery Protection </li> <li>1x Battery Connector (Deans M/F)</li> <li>1x Battery Cable (EP Silicone Cable 0.5mm\u00b2)</li> </ul> <p></p> <p>Solder the Battery Cables and Battery Connector to the Battery Protection Module. Use the Electronic System Architecture as reference.</p>"},{"location":"hardware/assembly_instructions/#step-9-dc-dc-converter","title":"Step 9: DC / DC Converter","text":"<p>Required Parts:</p> <ul> <li>1x HEL-06-03004-00 / DC/DC Converter</li> <li>1x HEL-06-04000-00 / Prototyping Board for DC/DC Converter</li> <li>1x HEL-06-03001-01 / LED Voltmeter </li> <li>1x HEL-06-03002-00 / Power Switch</li> </ul> <p></p> <p>Solder the connections of the DC/DC converter, LED Voltmeter, and Power Switch as shown in the image. The second image is mirrored so that you can compare it to the left image. Solder the connections according to the Electronic System Architecture and the Prototyping Board below.</p> <p></p>"},{"location":"hardware/assembly_instructions/#step-10-ciruit-board-box","title":"Step 10: Ciruit Board Box","text":"<p>Required Parts:</p> <ul> <li>HEL-04-04000-00 / Circuit Board Holder Base</li> <li>HEL-04-04001-00 / Circuit Board Holder Middle</li> <li>HEL-04-04002-00 / Circuit Board Holder Top</li> <li>3x ISO 4762 M3 x 30 / Screw M3x30</li> </ul> <p></p> <p>Place the Battery Protection on the Circuit Board Holder Base. Make sure that the cables are oriented correctly so that they leave the box as shown in the image. Place the Circuit Board Holder Middle on the Battery Protection Module.</p> <p></p> <p>Place the Prototyping Board with the DC/DC Converter on top of the Circuit Board Holder Middle . Assemble the whole Circuit Board Holder by using the Circuit Board Holder Top and 3x M3x30 screws.</p>"},{"location":"hardware/assembly_instructions/#step-11-voltmeter","title":"Step 11: Voltmeter","text":"<p>Required Parts:</p> <ul> <li>2x DIN 7985A - M2x5 /  Screw M2x5</li> <li>2x ISO - 4032 - M2 - D \u2013 N / Nut M2</li> </ul> <p></p> <p>Attach the voltmeter using 2x M2x5 screws and 2x M2 nuts.</p>"},{"location":"hardware/assembly_instructions/#step-12-power-switch","title":"Step 12: Power Switch","text":"<p>Attach the Power Switch with the 8 mm hex-head socket.</p>"},{"location":"hardware/assembly_instructions/#step-13-connect-cables","title":"Step 13: Connect Cables","text":"<p>Connect all the cables according to the Electronic System Architecture. The cables to the battery and the one power cable to the LIDAR remain unconnected for now.</p> <p>Good job! Now lets continue with assembling the last part - the body.</p>"},{"location":"hardware/assembly_instructions/#task-3-body","title":"Task 3: Body","text":"<p>Assembly Time</p> <p>20 minutes </p> <p>Tools needed</p> <ul> <li>2 mm hex-head key</li> <li>2.5 mm hex-head key</li> <li>18 mm wrench</li> </ul>"},{"location":"hardware/assembly_instructions/#step-1-add-threaded-bushes-to-body-and-camera-plate","title":"Step 1: Add Threaded Bushes to Body and Camera Plate","text":"<p>Required Parts:</p> <ul> <li>1x HEL-04-03002-00 / Body</li> <li>1x HEL-04-01013-02 / Camera Plate</li> <li>12x Thread Insert MULTISERT 003M3 / Threaded Bush</li> </ul> <p></p> <p>Press the threaded bushes into the Body and Camera Plate while heating them with a soldering iron.</p>"},{"location":"hardware/assembly_instructions/#step-2-power-supply-connector","title":"Step 2: Power Supply Connector","text":"<p>Required Parts:</p> <ul> <li>1x HEL-06-03000-00 / Power Supply Connector</li> </ul> <p></p> <p>Attach the Power Supply Connector to the robots body.</p>"},{"location":"hardware/assembly_instructions/#step-3-lidar","title":"Step 3: LIDAR","text":"<p>Required Parts:</p> <ul> <li>1x HEL-06-01008-00 / LIDAR</li> <li>1x HEL-06-01007-00 / LIDAR Adapter</li> <li>4x DIN 7984 - M3 x 8 --- 6.5N / Screw M3x8</li> </ul> <p></p> <p>Mount the LIDAR on the Body using 4x M3x8 screws.</p>"},{"location":"hardware/assembly_instructions/#step-4-camera","title":"Step 4: Camera","text":"<p>Required Parts:</p> <ul> <li>1x HEL-06-01006-00 / Camera</li> <li>4x DIN 7984 - M3 x 8 --- 6.5N / Screw M3x8</li> <li>2x DIN 7984 - M3 x 12 --- 10.5N / Screw M3x12</li> </ul> <p></p> <p>Mount the Camera onto the Camera Plate with 2x M3x12 screws. Then attach the camera assembly to the robots body using 4x Threaded Bush and 4x M3x8 screws.</p>"},{"location":"hardware/assembly_instructions/#step-5-merge-body-and-chassis","title":"Step 5: Merge Body and Chassis","text":"<p>Required Parts:</p> <ul> <li>4x DIN 7984 - M3 x 18 / Screw M3x18</li> </ul> <p></p> <p>Attach the body onto the chassis using 4x M3x18 screws.</p>"},{"location":"hardware/assembly_instructions/#step-6-battery-holder","title":"Step 6: Battery Holder","text":"<p>Required Parts:</p> <ul> <li>1x HEL-04-01004-00 / Battery Holder</li> <li>4x DIN 7984 - M3 x 8 --- 6.5N / Screw M3x8</li> </ul> <p></p> <p>Mount the Battery Holder on the bottom of the Frame Mount with 4x M3x8 screws.</p>"},{"location":"hardware/assembly_instructions/#step-7-mount-front-part","title":"Step 7: Mount Front Part","text":"<p>Required Parts:</p> <ul> <li>1x HEL-04-03003-00 / Front Part</li> <li>2x ISO 4762 M3 x 30 / Screw M3x30</li> </ul> <p></p> <p>Attach the Front Part to the Body with 2x M3x30 screws.</p>"},{"location":"hardware/assembly_instructions/#step-8-ipad-holder-optional","title":"Step 8: iPad Holder (optional)","text":"<p>Required Parts:</p> <ul> <li>1x HEL-04-02001-00 / iPad Holder</li> <li>4x ISO 4762 M3 x 40 / Screw M3x40</li> </ul> <p></p> <p>Optionally, an iPad Holder can be attached to HelMoRo with 4x M3x40 screws.</p>"},{"location":"hardware/assembly_instructions/#step-9-wheel-cap-optional","title":"Step 9: Wheel Cap (optional)","text":"<p>Required Parts:</p> <ul> <li>4x HEL-04-03000-01 / Wheel Cap</li> </ul> <p></p> <p>Optionally, Wheel Caps can be attached to the wheel.</p>"},{"location":"hardware/assembly_instructions/#step-10-fork-optional","title":"Step 10: Fork (optional)","text":"<p>Required Parts:</p> <ul> <li>1x HEL-04-03003-00 / Front Part with Fork</li> <li>4x ISO 4762 M3 x 30 / Screw M3x30</li> </ul> <p></p> <p>Optionally, the front part can be replaced and a Fork can be added. The Fork can be attached by using 4x M3x30 screws.</p>"},{"location":"hardware/bill_of_materials/","title":"Bill of Materials","text":"<p>All components of HelMoRo are listed below and structured in Electronic Parst, Generative Parts meaning those require a 3D printer, sheet metal parts that can be ordered from a workshop and all the needed fasteners.  The Bill of Materials should be used to order all the parts before starting the assembly process.</p> <p>Be aware that the total estimated costs of all parts of Helmoro are approximately: 1500.- Fr.</p> <p>Hint: Use the model-browser in the widget to search for a specific part name (naming convention). The widget shows the HelMoRo variant equipped with a Raspberry Pi 5, though the onboard computer could be assembled with a Jetson Nano too.</p>"},{"location":"hardware/bill_of_materials/#electronics","title":"Electronics","text":"QTY NAME DESCRIPTION PRODUCT CODE SUPPLIER PRICE PER UNIT (CHF) 1 Battery Cable EP Silicone Cable 0.5mm\u00b2 EP Silicone Cable 0.5mm\u00b2, red/black per 1m, 6059948 Digitec 6 2 Battery Connector Deans M/F EP Deans Connector, 6058001 Digitec 11 4 HEL-06-01000-01 Wheel pololu-wheel-90x10mm- black (4935) Robotshop 3 4 HEL-06-01002-00 Wheel Adapter Pololu 1083 Robotshop 4 1 HEL-06-01003-00 Jetson 02110268 - NVIDIA\u00ae Jetson Nano\u2122 Entwicklerkit Distrelec 113 2 HEL-06-01004-00 Motor Controller Kit RoboClaw IMC404 Robotshop 70 1 HEL-06-01005-00 Fan Geh\u00e4usel\u00fcfter Noctua NF-A4x10 FLX Brack 15 1 HEL-06-01006-00 Camera ASTRA PRO Orbbec3D Astra Pro Reichelt 200 1 HEL-06-01007-00 LIDAR Adapter Comes with LIDAR 1 HEL-06-01008-00 LIDAR RPLIDAR A2M8 360\u00b0 Laser Scanner Robotshop 320 4 HEL-06-01009-00 Motor FIT 0186 Robotshop 30 1 HEL-06-01010-00 Battery Swaytronic HC 3S 7200 mAh Galaxus 71 1 HEL-06-01011-00 Raspberry Pi 5 Raspberry Pi 5 8GB Digitec 86 1 HEL-06-03000-00 Power Supply Connector 1614 21 - Netzgera\u0308te-Einbaukupplung 5.4 x 8mm, Gerade, Lumberg Distrelec 5 1 HEL-06-03001-01 LED Voltmeter (0.28\" LED Digital DC Voltmeter 2.5VDC - 30VDC) RB-Spa-1481 / PRT-14313 Robotshop 2 1 HEL-06-03002-00 Power Switch (Miniature Toggle Switch ON-OFF Latching) RND 210-00494, Distrilec: 301-03-469 Distrilec 3 1 HEL-06-03003-00 IMU 2472 - IMU, Distrelec: 300-91-187 Distrelec 39 1 HEL-06-03004-00 DC/DC Converter 30W 5V 6A, Distrelec: 301-45-575 Distrelec 38 2 HEL-06-03005-00 USB A-Connector - USB Micro-B-Connector RND 765-00053, Distrilec: 301-25-761 Distrelec 2 1 HEL-06-04000-00 Prototyping Board for DC/DC Converter Robotshop 6 1 HEL-06-04001-00 Battery Protection hx-3s-fl25a-a Phipps, Alternative: Robotshop 13"},{"location":"hardware/bill_of_materials/#generative-parts","title":"Generative Parts","text":"QTY NAME DESCRIPTION PRODUCT CODE SUPPLIER PRICE PER UNIT (CHF) 2 Filament Filament for Hull Basf Filament, Digitec: 8817347 Digitec 30 1 HEL-04-01004-00 Battery Holder Helbling 3D Printer 1 HEL-04-01009-01 Motor Controller Plate Lasercutter 1 HEL-04-01013-02 Camera Plate Helbling 3D Printer 1 HEL-04-01017-01 Holder Motor Controller Helbling 3D Printer 1 HEL-04-02001-00 iPad holder Helbling 3D Printer 4 HEL-04-03000-01 Wheel Cap Helbling 3D Printer 1 HEL-04-03001-00 Body Helbling 3D Printer 1 HEL-04-03002-00 Front Part Helbling 3D Printer 50 1 HEL-04-03003-00 Front Part with Fork Helbling 3D Printer 50 1 HEL-04-03004-00 Base Plate for Jetson Lasercutter 1 HEL-04-04000-00 Circuit Board Holder Base Helbling 3D Printer 1 HEL-04-04001-00 Circuit Board Holder Middle Helbling 3D Printer 1 HEL-04-04002-00 Circuit Board Holder Top Lasercutter"},{"location":"hardware/bill_of_materials/#sheet-metals","title":"Sheet Metals","text":"QTY NAME DESCRIPTION PRODUCT CODE SUPPLIER PRICE PER UNIT (CHF) 1 HEL-04-01000-02 Frame Mount Schickli 100 1 HEL-04-01010-01 Top Plate Schickli 80 <p>The Top Plate can be ordered with the Clamping Nuts already pressed in.</p>"},{"location":"hardware/bill_of_materials/#fasteners","title":"Fasteners","text":"QTY NAME DESCRIPTION PRODUCT CODE SUPPLIER PRICE PER UNIT (CHF) 6 DIN 7984 - M3 x 12 --- 10.5N Screw M3x12 Stock 4 DIN 7984 - M3 x 18 - Screws M3x18 Stock 60 DIN 7984 - M3 x 8 --- 6.5N Screw M3x8 Stock 2 DIN 7985A - M2x5 Screw M2x5 Stock 2 ISO - 4032 - M2 - D - N Nut M2 Stock 4 ISO - 4032 - M2.5 - D - N Nut M 2.5 Stock 4 ISO 14581 M2.5x16x16- Screw M2.5x16 Stock 4 ISO 4762 M2 x 6 - 6N Screws M2x6 ISO 4762, Bossard Nr: 3 Stock 9 ISO 4762 M3 x 30 Screw M3x30 Stock 4 ISO 4762 M3 x 40 Screw M3x40 Stock 2 ISO 4762 M3x4 Screw M3x4 ISO 4762, Bossard Nr: 3 Bossard 12 PEM CLA-M3-1 ---N Clamping Nut (Pressed into Top Plate) Schickli 12 Thread Insert MULTISERT 003M3 Threaded Bush Gewindebuchsen f\u00fcr Kunststoffe 003-M3 kvt-fastening 3 4 Washer ISO 7092 - 2 Washer M2 Stock"},{"location":"hardware/cad/","title":"CAD","text":""},{"location":"hardware/cad/#downloads","title":"Downloads","text":"<p>In addition to the Fusion 360 Widget  (HelMoRo with Raspberry Pi 5), we provide the model in the following formats:</p> <ul> <li>Solidworks 2021 </li> <li>STEP </li> <li>STL </li> </ul> <p>Some files extend the file limit of 100 Mb, and therefore, we use GitHub LFS (Large File Storage) to manage these large files effectively. Instructions how to use GitHub LFS can be found under Collaboration.</p>"},{"location":"hardware/cad/#naming-convention","title":"Naming Convention","text":"<p>The file names are in the following format: HEL-XX-UUYYY-RR.xyz</p> <ul> <li> <p>HEL: This prefix represents the client.      \u00a0\u00a0\u00a0HEL: Helbling (internal project) </p> </li> <li> <p>XX: This section indicates the type of the CAD file.      \u00a0\u00a0\u00a001: Main assembly \u00a0\u00a0\u00a003: Sub-assembly \u00a0\u00a0\u00a004: Generative part or sheet metal \u00a0\u00a0\u00a006: Purchased electronic part     </p> </li> <li> <p>UU: The creator of the part is specified here. User 01 up to 04 exist.</p> </li> <li> <p>YYY: The number of the part is composed of a three-digit code that starts from 000 and increments by one for each new part.</p> </li> <li> <p>RR: The revision number is a two-digit code that starts from 00 and increases with each subsequent revision of the CAD file.</p> </li> <li> <p>xyz: File type.      \u00a0\u00a0\u00a0sldsasm: SolidWorks assembly file \u00a0\u00a0\u00a0sldprt: SolidWorks part file \u00a0\u00a0\u00a0step: STEP file \u00a0\u00a0\u00a0stl: STL file </p> </li> </ul>"},{"location":"hardware/cad/#additional-notes","title":"Additional Notes","text":"<ul> <li> <p>The part number (YYY) resets to 000 for different part types (XX) and for each user (UU). For example, both HEL-04-01000-00 and HEL-06-01000-00 may exist as one is a generative part or sheet metal and the other is an electronic part.</p> </li> <li> <p>Fasteners, such as screws and nuts, do not have a part number.</p> </li> </ul>"},{"location":"hardware/cad/#example","title":"Example","text":"<p>HEL-06-01000-01.sldprt</p> <ul> <li>HEL: Helbling</li> <li>06: Purchased electronic part</li> <li>01: User 1</li> <li>000: Part number 0</li> <li>000: Revision number 1</li> <li>sldprt: SolidWorks part file</li> </ul>"},{"location":"hardware/electronic_system_architecture/","title":"Electronic System Architecture","text":"<p>The electronic system architecture diagram provides an overview of the system's components and their interconnections. The part numbers are the same as in the Bill of Materials.</p> <p></p> <p>Download Electronical Architecture</p>"},{"location":"software_ros1/02_quick_start_guide/","title":"Quick Start Guide","text":"<p>After setting up ROS and (in the best case) all needed repositories on your computer following the Installation Guide you can use Helmoro. Helmoro can be run in simulation using gazebo locally on your computer or as a real robot. If you require more information and tips read chapter Detailed Usage.</p>"},{"location":"software_ros1/02_quick_start_guide/#quick-setup","title":"Quick Setup","text":""},{"location":"software_ros1/02_quick_start_guide/#simulation","title":"Simulation","text":"<p>To run Helmoro in simulation just add the following flags:</p> <pre><code>is_real_robot:=false use_rviz:=true use_gui:=true\n</code></pre> <p>to the end of the roslaunch command shown in Launching. This will start virtual Helmoro, RVIZ, Gazebo and the joystick reader on your local computer, e.g.</p> <pre><code>roslaunch helmoro_description nav_helmoro.launch is_real_robot:=false use_rviz:=true use_gui:=true\n</code></pre> <p>which should work out of the box, if you followed the Installation guide. The section Launching will provide you with further detail and different launch scripts.</p>"},{"location":"software_ros1/02_quick_start_guide/#real-robot","title":"Real Robot","text":"<p>To run the physical Helmoro you will need to set up your own computer to communicate with Helmoro. For that you first need to find out Helmoro's IP address and connect it to the same wireless network as the computer. Connecting Helmoro to the WiFi network is easiest done by plugging the Nvidia Jetson nano to an external monitor and connecting it to the wireless network using the ubuntu gui. As you will need to know its IP address later on it is convenient to assign it a static IP such that is stays constant within the network. This can be done via the router settings and is different for each router. The general idea is to link the Jetson mac address to some static IP.</p> <p>Remember both <code>&lt;Your_IP&gt;</code> being the IP of your linux system and <code>&lt;Helmoro_IP_address&gt;</code> being the IP of Helmoro in your used network. More info under Run.</p> <p>Now you will need to set environment variables on both devices. This is either done by typing the following commands in all terminals or by adding the following to your .bashrc and thus making it permanent per machine ('nano ~/.bashrc' and paste the lines below).</p> <pre><code>export ROS_IP=&lt;Your_IP&gt;\nexport ROS_MASTER_URI=http://&lt;Helmoro_IP_address&gt;:11311\n</code></pre> <p>The computer additionally needs the ROS_HOSTNAME in order to run the joystick manager.</p> <pre><code>export ROS_HOSTNAME=&lt;Your_IP&gt;\n</code></pre> <p>To run commands on Helmoro you will need to ssh into the NVIDIA Jetson:</p> <pre><code>ssh &lt;username&gt;@&lt;Helmoro_IP_address&gt;\n</code></pre> <p>Where <code>&lt;username&gt;</code> will be \"helmoro\" if you followed the Installation and <code>&lt;Helmoro_IP_address&gt;</code> being the IP of Helmoro in your used network.</p>"},{"location":"software_ros1/02_quick_start_guide/#launching","title":"Launching","text":"<p>Run these commands on Helmoro or locally depending on your desired Setup.</p>"},{"location":"software_ros1/02_quick_start_guide/#joystick-control","title":"Joystick control","text":"<p>In the simplest case one can drive Helmoro around using the Logitech joystick. The left 'LT' and right triggers 'LT' are x-velocity and the left digital stick controls the rotation.</p> <p>For this one needs to first start one of the many different launch files on Helmoro (by connecting via ssh) which also starts up the ROS Master. In the simplest case one starts the <code>helmoro.launch</code> which does not build a local obstacle map:</p> <pre><code>roslaunch helmoro_description helmoro.launch\n</code></pre> <p>Secondly one needs to actually start the joystick node on the local ubuntu computer which is connected to the same network. Before doing so make sure the joystick is connected via the usb receiver to the computer. Similarly, shift the switch to 'X' for XInput instead of 'D' for DirectInput such that floating point values will be broadcasted. Also make sure to press the 'mode'-button such that the LED next to it lights up. This is necessary for the correct mapping of the inputs.</p> <pre><code>roslaunch helmoro_joymanager joymanager.launch\n</code></pre> <p>Press the logitech button to wake up the controller, then press the 'LT' and 'RT' once to fully start the broadcasting of the velocity. To move forward use the 'RT' button while using the 'LT' Button to  move backwards. The left and right buttons on the left most (digital) joystick can be used to control the rotation.</p>"},{"location":"software_ros1/02_quick_start_guide/#autonomous-navigation-to-set-goal-positions","title":"Autonomous Navigation to set goal positions","text":"<p>Helmoro is able to navigate in a given space using the ROS Navigation Stack avoiding static and dynamic obstacles along the calculated path. In this mode it is possible to send helmoro to goals using RVIZ and use every functionality from joystick control. You need to use Helmoro in a premapped environment. The premapped environment is set in the move <code>move_base.launch</code> file. To run helmoro in new environment, first a map needs to be created with Remote controlled mapping or Autonomous mapping</p> <p>Run the following on helmoro (connected via ssh) to launch the autonomous navigation:</p> <pre><code>roslaunch helmoro_description nav_helmoro.launch\n</code></pre> <p>Once <code>nav_helmoro</code> is launched one can run the following on the local machine:</p> <pre><code>rosrun rviz rviz -d `rospack find helmoro_description`/rviz/rviz_config.rviz\n</code></pre> <p>This will start up Rviz and you can use the '2D Pose Estimate' and '2D Nav Goal' buttons to estimate its initial position and set its goal position on the map as in the image below. Make sure the checkmark for the occupancy map' is activated.</p> <p></p> <p>More information can be found in the chapter Autonomous Navigation using the Navigation Stack.</p>"},{"location":"software_ros1/02_quick_start_guide/#object-detection-and-autonomous-pickup","title":"Object detection and autonomous pickup","text":"<p>In this mode Helmoro saves the location of objects, which he sees with his camera, in a map. The objects are displayed in RVIZ. Afterwards he can be commanded to bring the object back to a before specified location (<code>global goal</code> in <code>helmoro_navigation_goals/param/parameters.yaml</code>). After Helmoro detected the objects, the user can pick a color using the colored buttons on the joystick. Afterwards he can push start to command Helmoro to get the most often seen object. The back button cancels all autonomous actions from Helmoro.</p> <pre><code>roslaunch helmoro_description showcase_helmoro.launch\n</code></pre> <p>More information on the detection of object can be found in chapter object_detector and about the storage of the objects in a map in chapter object map.</p>"},{"location":"software_ros1/02_quick_start_guide/#remote-controlled-mapping","title":"Remote controlled mapping","text":"<p>Helmoro can make use of a SLAM algorithm called gmapping, that uses the laser scans from the lidar and the odometry information coming from encoders and the IMU in order to build a map of obstacles.</p> <pre><code>roslaunch helmoro_description gmapping_helmoro.launch\n</code></pre> <p>For this to work, Helmoro can be remotely driven around by joystick until the map is fully registered. You can follow the status in RVIZ, when looking at the <code>occupancy map</code>. When finished run in a separate terminal on Helmoro</p> <pre><code>rosrun map_server map_saver -f &lt;location and name of your_map&gt;\n</code></pre> <p>will save the map for later use (edit <code>move_base.launch</code> accordingly).</p> <p>More detailed information can be found in SLAM using gmapping</p>"},{"location":"software_ros1/02_quick_start_guide/#autonomous-mapping","title":"Autonomous mapping","text":"<p>With the help of the <code>explore_lite</code> package Helmoro is able to map his environment by himself.</p> <pre><code>roslaunch helmoro_description explore_helmoro.launch\n</code></pre> <p>You can follow the status in RVIZ, when looking at the <code>occupancy map</code>. When finished run in a separate terminal on Helmoro</p> <pre><code>rosrun map_server map_saver -f &lt;location and name of your_map&gt;\n</code></pre> <p>will save the map for later use (edit <code>move_base.launch</code> accordingly).</p> <p>More detailed information can be found in Autonomous SLAM using explore_lite</p>"},{"location":"software_ros1/03_detailed_guide/","title":"Detailed Usage","text":"<p>In the following, it is explained how to use the Helmoro ROS architecture. Under <code>helmoro_description/launch/</code> you will find several launch files:</p> <ul> <li>helmoro.launch: Default launch file for Helmoro</li> <li>gmapping_helmoro.launch: Used for gmapping</li> <li>nav_helmoro.launch: Used for the Navigation Stack</li> <li>explore_helmoro.launch: Used for explore_lite</li> <li>showcase_helmoro.launch: Used for the showcase</li> </ul> <p>In the following, only the usage on the main launch file, helmoro.launch, on which all other launch files depend on, is explained. However using the other launch files works analogously. Head to the linked sections to discover more about the purpose and usage of the other launch files.</p>"},{"location":"software_ros1/03_detailed_guide/#run","title":"Run","text":"<p>The main launch file to run all the required nodes of the Helmoro ROS architecture is helmoro.launch in the package helmoro_description.</p> <p>In order to run Helmoro form a remote PC, you can use ssh as described in the following command.</p> <pre><code>ssh &lt;username&gt;@&lt;IP-address&gt;\n</code></pre> <p>Thereby, type in the username and instead of \"IP\" type in the IP-address of your Helmoro. Using this command, you can remotely log into the terminal of the Helmoro SBC and thus launch helmoro.launch from your remote device.</p> <p>Once connected to helmoro via ssh, run the launch file with the following commands:</p> <pre><code>roslaunch helmoro_description helmoro.launch\n</code></pre>"},{"location":"software_ros1/03_detailed_guide/#running-ros-across-multiple-machines","title":"Running ROS across Multiple Machines","text":"<p>In some cases, you want to run ROS across multiple machines for example to visualize the published data of Helmoro externally on RViZ. To do so, you can open up two windows in the terminal of one of your machines and connect one of your terminals via ssh to the other machine. Select one machine to run your master on. In our case, this would be the Helmoro. This is where you would start your roscore or a launch file such as helmoro.launch.</p> <p>A common problem, that occurs is that the machines cannot resolve each others hostname into an IP-address. Check if the IP-address of each machine is visible by typing:</p> <pre><code>echo $ROS_IP\n</code></pre> <p>If there is no IP-address showing up, you can set ROS_IP in each machine environment before starting a node by typing:</p> <pre><code>export $&lt;Your_IP&gt;\n</code></pre> <p>You can also use the following script in each terminal, after you filled in the required values</p> <pre><code>#!/bin/bash\n\nsource /opt/ros/noetic/setup.bash\n\n# select workspace\nsource /home/$USER/&lt;Your catkin workspace&gt;/devel/setup.bash\n\n# set IP of localhost, ethernet or wifi for using remote roscore\nip_temp=$(hostname -I)\n#my_ip = localhost\nmy_ip=${ip_temp% }\n\n# set IP of roscore\nroscore_ip=$my_ip\n\nexport ROS_IP=$my_ip\nexport ROS_HOSTNAME=$my_ip\nexport ROS_MASTER_URI=http://$roscore_ip:11311\n</code></pre> <p>Then, enter the following commands in both terminals:</p> <pre><code>export ROS_MASTER_URI=http://&lt;IP_of_Master&gt;:11311\n</code></pre> <p>Thereby, type in the IP-address of your master-machine instead of . <p>For further testing, you can use the rostopic tool on all machines that are connected to the master. Using the command <code>rostopic list</code> you should get a list of all available topics. In wireless networks, which our Helmoro uses, it is sometimes necessary to check if there is a connection and messages still come. You can do so by echoing a published topic.</p> <pre><code>rostopic echo /topic_name\n</code></pre> <p>If you are in the HTKZ lab network you can look for Helmoro's IP here</p> <p>For further reference head to ROS MultipleMachines and ROS NetworkSetup.</p>"},{"location":"software_ros1/03_detailed_guide/#run-rviz-with-a-config-file","title":"Run RViZ with a config file","text":"<p>In order to run RViZ as a standalone directly with the custom config file, type in:</p> <pre><code>rosrun rviz rviz -d `rospack find helmoro_description`/rviz/rviz_config.rviz\n</code></pre>"},{"location":"software_ros1/03_detailed_guide/#arguments","title":"Arguments","text":"<p>You can pass several arguments to the helmoro.launch and other launch files, when running it using:</p> <pre><code>roslaunch helmoro_description helmoro.launch arg_name:=value\n</code></pre>"},{"location":"software_ros1/03_detailed_guide/#usage-arguments","title":"Usage Arguments","text":"<p>The most important arguments for usage are depicted in the following table.</p> Parameter Default Definition is_real_robot true Switch to use real robot or gazebo simulation use_rviz false Switch to use rviz for visualization also activates the joystick use_joystick = use_rviz Switch to use joystick use_lidar true Switch to use lidar use_rgbd_camera true Switch to use rgbd camera"},{"location":"software_ros1/03_detailed_guide/#rviz-arguments","title":"RVIZ Arguments","text":"Parameter Default Definition rviz_config_file rviz_config.rviz Default rviz config file"},{"location":"software_ros1/03_detailed_guide/#gazebo-arguments","title":"Gazebo Arguments","text":"Parameter Default Definition paused false Switch if gazebo is started running or in paused mode use_sim_time true Switch if simulated gazebo time or real time is used for simulation gui false Switch if gui of gazebo is displayed world helmoro_gazebo_plugin/worlds/helmoro_wohnung_mob Default testing world that is loaded for gazebo simulation"},{"location":"software_ros1/03_detailed_guide/#common-commands","title":"Common commands","text":"<p>To run Helmoro in simulation (in Gazebo) you can call this command on your local computer:</p> <pre><code>roslaunch helmoro_description showcase_helmoro.launch is_real_robot:=false use_rviz:=true use_gui:=true\n</code></pre> <p>You then can add a box into the environment and let Helmoro pick it up. Be reminded that in simulation helmoro does not have a fork (but he can push around objects) and that the odometry is better then in reality.</p> <p>To run the required nodes for the showcase on Helmoro you can run:</p> <pre><code>roslaunch helmoro_description showcase_helmoro.launch\n</code></pre> <p>Additionally, the above written command to call rviz on your local computer</p> <pre><code>rosrun rviz rviz -d `rospack find helmoro_description`/rviz/rviz_config.rviz\n</code></pre> <p>You then also need to start the joystick node (on your computer) with:</p> <pre><code> roslaunch helmoro_joymanager joymanager.launch\n</code></pre> <p>Make sure to connect the joystick to your computer</p>"},{"location":"software_ros1/03_detailed_guide/#advanced-usage-or-tuning","title":"Advanced usage or tuning","text":"<p>If you want to tune the parameters of amcl or the navigation stack, while Helmoro is running you can open the dynamic reconfigure plugin after running:</p> <pre><code>rosrun rqt_gui rqt_gui\n</code></pre>"},{"location":"software_ros1/04_installation_guide/","title":"Installation","text":"<p>The packages included in Helmoro support ROS Noetic on Ubuntu 20.04.</p> <ol> <li> <p>Install ROS Noetic on Helmoros Nvidia Jetson and on your local machine.</p> </li> <li> <p>Create a ROS Workspace</p> <pre><code>sudo apt install python3-catkin-tools\nmkdir -p ~/catkin_ws/src\ncd ~/catkin_ws/\ncatkin build\nsource devel/setup.bash\n</code></pre> <p>Either you must run the above source command each time you open a new terminal window or add it to your .bashrc file as follows</p> <pre><code>echo \"source ~/catkin_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre> </li> <li> <p>Clone the repository into your catkin workspace. The commands are stated in the following.</p> <pre><code>cd ~/catkin_ws/src\ngit clone https://github.com/Helbling-Technik/HelMoRo-software.git\n</code></pre> </li> </ol> <p>After that, clone the required repositories and make the required installations listed in the next section Dependencies.</p>"},{"location":"software_ros1/04_installation_guide/#dependencies","title":"Dependencies","text":"<p>In the following, the packages and stacks which are required to run the Helmoro are mentioned. Do not forget to build the acquired packages once you cloned them into your workspace.</p>"},{"location":"software_ros1/04_installation_guide/#overview","title":"Overview","text":"<ul> <li>catkin_simple</li> <li>any_node:</li> <li>message_logger</li> <li>any_node</li> <li>joystick_drivers stack</li> <li>helmoro_rplidar</li> <li>ros_astra_camera_helmoro</li> <li>ros_imu_bno055</li> <li>Navigation Stack</li> <li>gmapping</li> <li>explore_lite</li> </ul> <p>Clone or download all the required repositories or stacks all together with the following commands</p> <pre><code>sudo apt-get install ros-noetic-joy\ncd ~/catkin_ws/src\ngit clone https://github.com/catkin/catkin_simple.git\ngit clone https://github.com/ANYbotics/message_logger.git\ngit clone https://github.com/ANYbotics/any_node.git\ngit clone https://github.com/Helbling-Technik/Helmoro_RPLidar\ngit clone --branch Helmoro_2.0 https://github.com/Helbling-Technik/ros_astra_camera_helmoro\nsudo apt install ros-noetic-rgbd-launch\ngit clone https://github.com/dheera/ros-imu-bno055.git\nsudo apt install ros-noetic-libuvc-camera ros-noetic-libuvc-ros ros-noetic-navigation ros-noetic-slam-gmapping\ngit clone https://github.com/hrnr/m-explore.git\ncd ~/catkin_ws/\n</code></pre> <p>You should now be able to build all the installed packages with the followiung command</p> <pre><code>catkin build\n</code></pre> <p>In order to build and run the object_detector and the hand_detector, you will need to install additional OpenCV libraries. Please see 5.11 OpenCV for details.</p>"},{"location":"software_ros1/04_installation_guide/#catkin_simple","title":"catkin_simple","text":"<p>catkin_simple is a package, that simplifies the task of writing CMakeLists.txt for a package. It is used in several packages and therefore required in order for them to be built properly using <code>catkin build</code>.</p>"},{"location":"software_ros1/04_installation_guide/#any_node","title":"any_node","text":"<p>any_node is a set of wrapper packages to handle multi-threaded ROS nodes. Clone or download the following repositories into your catkin workpace:</p> <ul> <li> <p>message_logger</p> </li> <li> <p>any_node</p> </li> </ul>"},{"location":"software_ros1/04_installation_guide/#joystic_drivers-stack","title":"joystic_drivers stack","text":"<p>This stack allows a joystick to communicate with ROS. Note that the Helmoro packages work exclusively with the Logitech Wireless joystick F710controller. Additionally to the installation, it is useful to install the joystick testing and configuration tool</p> <pre><code>sudo apt-get install jstest-gtk\n</code></pre> <p>You can test the connection of your joystick by running <code>jstest-gtk</code> from terminal. Please check the device name (Helmoro packages use default joystick name \"js0\"). Also ensure that the mapping of the joystick is according to this screenshot:</p> <p></p> <p>Ensure that you save the mapping for next time.</p> <p>If your joystick has a different name eighter overwrite this value or pass your joystick name as an argument when launching the helmoro.launch file, which is explained in the following. To test the joystick functionality with ros run the following commands in two separate terminals:</p> <pre><code>roscore\n</code></pre> <pre><code>rosrun joy joy_node\n</code></pre> <p>If you listen to the topic /joy while using the joystick you should see the commands being published to the corresponding topic.</p> <pre><code>rostopic echo /joy\n</code></pre> <p>joy roswiki</p>"},{"location":"software_ros1/04_installation_guide/#helmoro_rplidar","title":"helmoro_rplidar","text":"<p>This package allows a Slamtec RPLidar to communicate with ROS. The repository has been derived from the official rplidar_ros. However, a small change in node.cpp had to be made for compatibility with the Helmoro and especially with the Navigation Stack.</p> <p>The change that has been made can be found on line 61 of src/Node.cpp which now says:</p> <pre><code>scan_msg.header.stamp = ros::Time::now();\n</code></pre> <p>Instead of previously:</p> <pre><code>scan_msg.header.stamp = start;\n</code></pre> <p>Clone the helmoro_rplidar repository into your workspace. This will create a package, still called rplidar_ros</p> <p>Before you can run the rplidar, check the authority of its serial port.</p> <pre><code>ls -l /dev |grep ttyUSB\n</code></pre> <p>To add the authority to write to it:</p> <pre><code>sudo chmod 666 /dev/ttyUSB0\n</code></pre> <p>In order to fix the rplidar port and remap it to /dev/rplidar input the following command to your terminal</p> <pre><code>~/catkin_ws/src/rplidar_ros/scripts/create_udev_rules.sh\n</code></pre> <p>Once you have remapped the rplidar USB port, change the rplidar launch files about the serial_port value.</p> <pre><code>&lt;param name=\"serial_port\" type=\"string\" value=\"/dev/rplidar\"&gt;\n</code></pre> <p>You can run the rplidar as a standalone by typing the following command into your terminal:</p> <pre><code>roslaunch rplidar_ros rplidar.launch\n</code></pre> <p>For further information, head to:</p> <ul> <li>rplidar roswiki</li> <li>rplidar Tutorial</li> </ul>"},{"location":"software_ros1/04_installation_guide/#ros_astra_camera","title":"ros_astra_camera","text":"<p>This package allows a Orbbec Astra RGB-D camera to communicate with ROS. Through it, images and pointclouds coming from the camera as well as transformations between the different frames are published as topics.</p> <p>Clone the ros_astra_camera_helmoro repository into your workspace, switch to the branch <code>Helmoro_2.0</code> and install its dependencies by entering the following command into your terminal and replace <code>ROS_DISTRO</code> by the ROS distribution you are currently using (in this case <code>melodic</code>):</p> <pre><code>sudo apt install ros-$ROS_DISTRO-rgbd-launch ros-$ROS_DISTRO-libuvc ros-$ROS_DISTRO-libuvc-camera ros-$ROS_DISTRO-libuvc-ros\n</code></pre> <p>You can run the astra camera as a standalone by typing the following command into your terminal:</p> <pre><code>roslaunch astra_camera astra.launch\n</code></pre> <p>We had to fork the normal ros_astra_camera repository, as we needed to change some small values in the tf of the camera.</p>"},{"location":"software_ros1/04_installation_guide/#ros_imu_bno055","title":"ros_imu_bno055","text":"<p>This repository provides a node that lets the BNO055 IMU, which is built into Helmoro, publish its fused as well as its raw data over ROS via i2c.</p> <p>Clone the ros_imu_bno055 repository into your workspace.</p> <p>In order to get the imu_bno055 package to work, first check if the IMU shows up in the i2c-ports.</p> <pre><code>ls -l /dev/i2c*\n</code></pre> <p>Furthermore, check you can run</p> <pre><code>sudo i2cdetect -y -r 1\n</code></pre> <p>You should be able to see your device at address 0x28, which is the default address of the IMU BNO055.</p> <p>If everything works, you can run your IMU by simply launching:</p> <pre><code>roslaunch imu_bno055 imu.launch\n</code></pre>"},{"location":"software_ros1/04_installation_guide/#gmapping","title":"gmapping","text":"<p>Gmapping is a SLAM algorithm that can be used for the task of mapping an environment using a Lidar and the robot's odometry information.</p> <p>Gmapping can be installed using the following command:</p> <pre><code>sudo apt-get install ros-melodic-slam-gmapping\n</code></pre> <p>For more details about SLAM gmapping, head to section Slam using Gmapping</p>"},{"location":"software_ros1/04_installation_guide/#navigation-stack","title":"Navigation Stack","text":"<p>The navigation stack allows Helmoro to navigate autonomously by using the sensor data of the rplidar, astra camera and odometry.</p> <p>Install the navigation stack by typing the following command into your terminal:</p> <pre><code>sudo apt-get install ros-melodic-navigation\n</code></pre> <p>For more details about SLAM gmapping, head to section Autonomous Navigation using the Navigation Stack</p>"},{"location":"software_ros1/04_installation_guide/#explore_lite","title":"explore_lite","text":"<p>In order to let Helmoro map its environment autonomously, you can make use of the explore_lite package.</p> <p>Clone the explore_lite repository into your workspace.</p> <p>For more details about explore_lite, head to section Autonomous Slam using explore_lite</p>"},{"location":"software_ros1/04_installation_guide/#opencv","title":"OpenCV","text":""},{"location":"software_ros1/04_installation_guide/#background","title":"Background","text":"<p>The Jetson Nano's default software repository contains a pre-compiled OpenCV 4.1 library (can be installed using <code>sudo apt install ...</code>).</p> <p>The pre-compiled ROS tools all use OpenCV 3.2 (if ROS is installed using <code>sudo apt install ...</code>). If a custom ROS node uses OpenCV, it will use OpenCV 4.1 when being compiled, and is thus not compatible with other ROS tools/nodes (you might be lucky, but the object_detector uses incompatible OpenCV functions). It is thus required to install OpenCV 3.2 on the Jetson Nano, and since no pre-compiled library of OpenCV 3.2 for the Jetson Nano exists, this must be done from source.</p> <p>Google's mediapipe uses OpenCV 4, and it is straightforward to compile the hand_detector node. However, GPU support is not enabled in the pre-compiled OpenCV 4.1 library. Hence, the OpenCV 4.1 library must also be installed from source if the hand_detector node should run on the GPU (recommended).</p>"},{"location":"software_ros1/04_installation_guide/#installing-opencv-32-or-4","title":"Installing OpenCV 3.2 or 4","text":"<ol> <li>Create a temporary directory, and switch to it:</li> </ol> <pre><code>mkdir ~/opencv_build &amp;&amp; cd ~/opencv_build`\n</code></pre> <ol> <li>Download the sources for OpenCV 3.2 or OpenCV 4 (any version &gt; 4 should work) into <code>~/opencv_build</code>. You will need both <code>opencv</code> and <code>opencv_contrib</code> packages. The source files can be downloaded under the following links: opencv, opencv_contrib.</li> <li> <p>Make a temporary build directory and unzip the folders in your build directory. The folder structure should look like this:</p> <pre><code>~/opencv_build/\n~/opencv_build/opencv/\n~/opencv_build/opencv_contrib/\n</code></pre> </li> <li> <p>Create a build directory, and switch to it:</p> <pre><code>cd ~/opencv_build/opencv\nmkdir build &amp;&amp; cd build\n</code></pre> </li> <li> <p>Set up the OpenCV build with CMake. For a basic installation:</p> <pre><code>cmake -D CMAKE_BUILD_TYPE=RELEASE \\\n-D CMAKE_INSTALL_PREFIX=/usr/local \\\n-D INSTALL_C_EXAMPLES=ON \\\n-D INSTALL_PYTHON_EXAMPLES=ON \\\n-D OPENCV_GENERATE_PKGCONFIG=ON \\\n-D OPENCV_EXTRA_MODULES_PATH=~/opencv_build/opencv_contrib/modules \\\n-D BUILD_EXAMPLES=ON ..\n</code></pre> <p>To configure your OpenCV build more easily, install a CMake GUI, <code>sudo apt install cmake-qt-gui</code> or <code>sudo apt install cmake-curses-gui</code> and run it with <code>cmake-gui</code>.   To run the hand_detector on GPU, which is based on Google's mediapipe, you need to configure your OpenCV build to support CUDA/GPU.</p> </li> <li> <p>Start the compilation process:</p> <pre><code>make -j8\n</code></pre> <p>Modify the <code>-j</code> according to the number of cores of your processor. If you don't know the number of cores, type <code>nproc</code> in your terminal.</p> <p>The compilation will take a lot of time. Go grab a coffee and watch some classic youtube videos.</p> </li> <li> <p>To verify whether OpenCV has been installed successfully, type the following command.</p> <pre><code>pkg-config --modversion opencv4\n</code></pre> <p>(adjust the command for <code>opencv3</code>, <code>opencv2</code>, ...).</p> </li> </ol>"},{"location":"software_ros1/05_software_architecture/","title":"Architectural Overview","text":"<p>The following flowchart shows an overview of the ROS architecture of Helmoro including internal and external packages when the parameter <code>is_real_robot</code> is set to true and gazebo is not running. The internal packages will be briefly explained in section Packages. External Packages will be explained in section Dependencies. Additionally, packages used for SLAM (gmapping), Autonomous Navigation (Nav Stack) and Autonomous SLAM (explore_lite) are further explained in their respective sections.</p> <p></p>"},{"location":"software_ros1/05_software_architecture/#packages","title":"Packages","text":"<p>In the following, each package of the Helmoro ROS architecture is explained shortly.</p>"},{"location":"software_ros1/05_software_architecture/#helmoro_description","title":"helmoro_description","text":""},{"location":"software_ros1/05_software_architecture/#launch-files","title":"launch files","text":"<ul> <li>helmoro.launch: Main launch file, that starts all the required nodes for Helmoro.</li> <li>gmapping_helmoro.launch: Launch file for gmapping (for customizable parameters).</li> </ul>"},{"location":"software_ros1/05_software_architecture/#param","title":"param","text":"<ul> <li>default.yaml stores Helmoro's hardware specs and is used by many different nodes.</li> </ul>"},{"location":"software_ros1/05_software_architecture/#urdf-and-meshes","title":"urdf and meshes","text":"<ul> <li>Meshes and .urdf files are used for the physical description of Helmoro. They define orientation and position of the different hardware components to each other. This is used to build a robot model, that can be visualized in rviz, for tf information of the different frames that are published to <code>/tf</code> using helmoro_state_publisher and for the specification of the sensor streams that should be simulated in gazebo.</li> </ul>"},{"location":"software_ros1/05_software_architecture/#rviz","title":"rviz","text":"<ul> <li>rviz_config.rviz: rviz config file, that describes the default rviz settings for Helmoro.</li> </ul> <p>Package where all the required custom messages and services for Helmoro are described.</p>"},{"location":"software_ros1/05_software_architecture/#helmoro_joymanager","title":"helmoro_joymanager","text":""},{"location":"software_ros1/05_software_architecture/#launch-files_1","title":"launch files","text":"<ul> <li>joymanager.launch: Calls the two nodes joy_node (remapped as helmoro_joystick) and helmoro_joymanager and loads the parameters described in parameters.yaml</li> </ul>"},{"location":"software_ros1/05_software_architecture/#nodes","title":"nodes","text":"<ul> <li>joy_node: interprets the joystick commands coming from the Logitech Wireless joystick F710 controller and publishes them over a message of type sensor_msgs/Joy to the topic <code>/helmoro_joystick</code></li> <li>helmoro_joymanager_node: Subscribes to the <code>/helmoro_joystick</code> topic, scales the joystick commands and publishes a message of type geometry_msgs/Twist on the topic <code>/cmd_vel</code> describing the desired linear and angular movement of the Helmoro.</li> </ul>"},{"location":"software_ros1/05_software_architecture/#helmoro_motor_commands","title":"helmoro_motor_commands","text":"<p>The helmoro_motor_commands package is only used if <code>is_real_robot</code> is set to true and used for sending desired speed commands to the motor controllers and reading out the angular speeds and position coming from the encoders. Information on the setup of the RoboClaw Motor Controllers can be found here:</p> <p> <p></p> <p></p> Option 1 Option 2 Wiring - Wire one of the two RoboClaws to the Jetson Nano SBC via Micro-USB to Micro-USB cable - Wire the second RoboClaw to the first with UART. Don\u2019t forget to connect the Ground and to Switch RX and TX. - RoboClaw: RX on S1 pin, TX on S2 pin - Wire both RoboClaws to the Jetson Nano SBC via Micro-USB to Micro-USB cable Setting - Connect one RoboClaw to PC via USB and open it with the downloaded BasicmicroMotionStudio - Set first RoboClaw to USB-TTL Relay Mode in the General Settings - Leave second RoboClaw as it is. No Multi-Unit Mode! - Set a unique address for each RoboClaws in the General Settings in order for them not to conflict with each other - Set Baudrate you would like to use in the General Settings - Configure the PID values of the RoboClaws if not yet done. - Don\u2019t forget to Device $\\rightarrow$ Write Settings in the top left corner before disconnecting your RoboClaw. - Connect one RoboClaw to PC via USB and open it with the downloaded BasicmicroMotionStudio - Don\u2019t set any of the two RoboClaws to USB-TTL Relay Mode - Set an address for each RoboClaw in the General Settings. Note for this wiring, the addresses can be equal since ports are different (/dev/ttyACM0 and /dev/ttyACM1 in Linux) - Set Baudrate you would like to use in the General Settings - Configure the PID values] of the RoboClaws if not yet done. - Don\u2019t forget to Device $\\rightarrow$ Write Settings in the top left corner before disconnecting your RoboClaw"},{"location":"software_ros1/05_software_architecture/#nodes_1","title":"nodes","text":"<ul> <li>helmoro_motor_commands: Subscribes to <code>/cmd_vel</code> and <code>/imu/data</code> and computes the desired wheel speed using a straight forward computation and an integral term that sums up the error between the desired and actual (imu measured) angular speed of Helmoro's base. It sends the computed speeds to the two motor controllers and in turn reads the wheel speeds and positions and publishes them as a custom message on <code>/helmoro_joint_states</code>. Messages are sent and read from the motor controllers using the functions defined under motor_interface. They actually imitate the functions from the RoboClaw Python Library for C++ usage. (see <code>motor_command_types.h</code> for the according command numbers and compare them to the numbers used in the python library or in <code>helmoro_roboclaw</code>).</li> </ul>"},{"location":"software_ros1/05_software_architecture/#comments","title":"comments","text":"<ul> <li>In order for commands to be sent and received at a high baudrate (such as the currently set value of 115200), both roboclaw motor controllers need to be connected to the Jetson Nano by USB since bits cannot be sent over serial connections at such a high rate without errors occurring in the data transmission process. If you want to cable your motor controllers differently, you can connect a USB cable to one of the two motor controllers and connect the second to the first via UART (remember to adjust the first Roboclaw motor controller to be in USB-TTL relay mode in the BasicMicro Motion Studio). For that setting however, the baudrate needs to be set to a lower value such as 38400 for the messages not to turn out erroneous. Bear in mind, that then the individual motor_interface functions will require more time and therefore the node might not be able to run at the same rate anymore, which then needs to be adjusted. Also, if you want to change to this setting, you will need to adjust the node so that only one motor_interface instance with one portname is created and only the address is varied to communicate with the left and right motor controller.</li> </ul>"},{"location":"software_ros1/05_software_architecture/#troubleshooting","title":"troubleshooting","text":"<p>In case you are getting errors from this package and the Roboclaw Motor Controllers are not working, go through the following quick checks:</p> <ol> <li>Check if the port name of both Roboclaws appear when plugin in, the USB by typing <code>ls /dev/ttyACM*</code></li> <li>Check if you have the authority to write to this port. Otherwise type <code>chmod 666 &lt;portname&gt;</code> in order to add the authority.</li> <li>Also, when using this node with two USB cables, it can happen that the portnames of the left and the right roboclaw motor controller swap (<code>/dev/ttyACM0</code> &lt;-&gt; <code>/dev/ttyACM1</code>). Since, to this point their USB ports are not fixed. If this happens, simply swap the two addresses for the left and the right controller specified in the param file.</li> </ol>"},{"location":"software_ros1/05_software_architecture/#helmoro_gazebo_plugin","title":"helmoro_gazebo_plugin","text":"<p>This package is only used, when the argument <code>is_real_robot</code> in helmoro.launch is set to false. Package that is used to run the gazebo simulation.</p>"},{"location":"software_ros1/05_software_architecture/#nodes_2","title":"nodes","text":"<ul> <li>helmoro_gazebo_plugin: Custom gazebo-plugin for the Helmoro, which simulates the wheel ground interaction.</li> </ul>"},{"location":"software_ros1/05_software_architecture/#worlds","title":"worlds","text":"<p>Built worlds in which gazebo simulation can be started.</p>"},{"location":"software_ros1/05_software_architecture/#helmoro_state_publisher","title":"helmoro_state_publisher","text":""},{"location":"software_ros1/05_software_architecture/#nodes_3","title":"nodes","text":"<ul> <li>helmoro_state_publisher_node: Subscribes to <code>/helmoro_joint_states</code> and <code>/imu/data</code> coming from an imu package called imu_bno055 (described under dependencies). The node computes the Helmoro odometry thereof and publishes it as a message of type nav_msgs::Odometry onto the <code>/odom</code> and onto <code>/tf</code>. It also publishes the static transforms, defined in helmoro_description/urdf and the wheel positions of Helmoro onto <code>/tf</code>.</li> </ul>"},{"location":"software_ros1/05_software_architecture/#helmoro_local_obstacle","title":"helmoro_local_obstacle","text":""},{"location":"software_ros1/05_software_architecture/#nodes_4","title":"nodes","text":"<ul> <li>helmoro_local_obstacle_node: Subscribes to the <code>/camera/depth/points</code> topic of message type sensor_msgs/PointCloud2 coming from the astra_camera package which is described below. The node simply downsamples the incoming pointcloud using a VoxelGrid filter and publishes it as <code>/pointcloud_filtered</code>.</li> </ul>"},{"location":"software_ros1/05_software_architecture/#helmoro_2dnav","title":"helmoro_2dnav","text":"<p>This package holds all the used launch and parameter files for the custom usage of the Navigation Stack with Helmoro. For more information, head to Navstack section.</p>"},{"location":"software_ros1/05_software_architecture/#object_detector","title":"object_detector","text":""},{"location":"software_ros1/05_software_architecture/#description","title":"Description","text":"<p>Helmoro can detect coloured cubic objects and locate them using its RGB-D camera Once detected, the location of these objects is saved into a map, so that they can be targeted by the navigation stack. The object_detector looks for colored boxes in an image and outputs their 3D position in the map frame. (included in showcase_helmoro.launch)</p>"},{"location":"software_ros1/05_software_architecture/#limitations","title":"Limitations","text":"<p>Since the object detection algorithm used mainly checks for colours, the lighting conditions strongly influence the performance of this task.</p>"},{"location":"software_ros1/05_software_architecture/#nodes_5","title":"nodes","text":"<ul> <li>object_detector: Subscribes to <code>/camera/rgb/camera_info</code> for the camera intrinsics, <code>/camera/rgb/image_raw</code> for the color image to find the objects, <code>/camera/depth/image_raw</code> for the depth information when objects in the color image were found. Publishes a custom message to <code>object_detector/object_detections</code> that contains all found objects in the current image, their color and their 3D position in the map frame. For debugging purposes, an image is published to <code>object_detector/object_detections_image</code> that indicates with black dots all the objects that were found.  You can have a look at it using 'rqt_image_view'.   <pre><code>rosrun rqt_image_view rqt_image_view\n</code></pre></li> </ul>"},{"location":"software_ros1/05_software_architecture/#object_map","title":"object_map","text":"<p>The object_map maintains a map of all detected objects. If a detection is made close to a previous detection, it fuses both measurements instead of creating a new one. The distance under which this happens is configurable in the parameter file. All objects in the map are assigned a unique identification number such that it one can easily refer to a specific object. It publishes a service, where it sends the most often seen object from a specific colour to the requester (<code>/object_map/request_object</code>) and a service with which it is possible to edit (currently only delete) a specific object (<code>/object_map/edit_map</code>).</p>"},{"location":"software_ros1/05_software_architecture/#nodes_6","title":"nodes","text":"<ul> <li>object_map: Subscribes to <code>/object_detector/object_detections</code> for all current object detections. All objects are put in a map and assigned a unique id. If the object already exists, its position is updated using a filter. It publishes a service, where it sends the most often seen object from a specific colour to the requester (<code>/object_map/request_object</code>) and a service with which it is possible to edit (currently only delete) a specific object (<code>/object_map/edit_map</code>).</li> </ul>"},{"location":"software_ros1/05_software_architecture/#comments_1","title":"comments","text":"<ul> <li>The object map keeps track of the certainty of an object in an absolute way, meaning it tracks how often a specific object was send by the object_detector.</li> <li>In the current implementation, objects are never automatically removed from the map. One could think of removing objects if the Helmoro looks at an object for a long time, but does not see it.</li> </ul>"},{"location":"software_ros1/05_software_architecture/#helmoro_navigation_goals","title":"helmoro_navigation_goals","text":"<p>This package is used for sending navigation goals to the navigation stack based on the location of the detected objects from the object map. (included in showcase_helmoro.launch)</p>"},{"location":"software_ros1/05_software_architecture/#nodes_7","title":"nodes","text":"<ul> <li>helmoro_navigation_goals: Requests new objects (with their location) from the map via a rosservice <code>/object_map/request_object</code> (type <code>RequestObjectFromMap.srv</code>) and commands the robot to collect them. It does that, by going through a simple State machine and sending the computed goals to the navigation stack using _actionlib* (as described on this ROS wiki).</li> <li>The task to collect the objects after they are added to the map can be started by pushing the <code>start</code> button on the joystick controller.</li> <li>At all times, during the object collection task the <code>back</code> button on the joystick controller can be used to cancel the collection of the objects and the following of the trajectories.</li> <li>When Helmoro is prepared to pick up the object, this node requests the deletion of the collected object from the map with the ros service <code>/object_map/edit_map</code> (type: <code>EditObjectMap.srv</code>).</li> <li>When Helmoro picks the object up, he changes his minimum forward speed (<code>min_vel_x</code>) to a positive value (configurable). Like this it is ensured, that Helmoro does not drive backwards or rotates in place, as this could lead to the loss of the object. He also edits his own goal acceptance tolerance to ensure no endless rotations at the global_goal by changing <code>xy_goal_tolerance</code>(configurable). When Helmoro reaches the global goal and delivered the object he then reverts both values to their original value to be able to navigate normally. (The original values is configured in the param file of the DWAPlanner).</li> <li>Helmoro has two ways how to pick up an object. This can be specified by selection <code>target_mode</code> in the parameter file.</li> <li>Target mode 1: Helmoro drives around the object and turns behind it. He then pushes it to the global_goal.</li> <li>Target mode 2: Helmoro drives straight on to the object and then turns with it.</li> </ul>"},{"location":"software_ros1/06_algorithms/","title":"High Level Algorithms","text":""},{"location":"software_ros1/06_algorithms/#slam-using-gmapping","title":"SLAM using gmapping","text":"<p>Gmapping is a SLAM algorithm that can be used to generate a global map that can be used in autonomous navigation. It requires a horizontally fixed laser range finder(lidar) and subscribes to the <code>/scan</code> topic. Further it subscribes to <code>/tf</code> needing to know the transform between the lidar and the base_link and between the base_link and odom. In turn, it provides the transform between odom and the map frame to <code>/tf</code> and publishes the constantly updated map under the <code>/map</code> topic.</p>"},{"location":"software_ros1/06_algorithms/#run","title":"Run","text":"<p>To create a map launch your helmoro in the desired environment (in gazebo or in real life)</p> <pre><code>roslaunch helmoro_description helmoro.launch\n</code></pre> <p>Open up a new terminal and enter</p> <pre><code>rosrun gmapping slam_gmapping scan:=scan\n</code></pre> <p>While this node is running drive around with your helmoro in the environment. This node will create a occupancy map using SLAM. When you are done driving around leave all the terminals running, open up a new one and enter</p> <pre><code>rosrun map_server map_saver -f &lt;location and name of your_map&gt;\n</code></pre> <p>This will create a your_map.pgm and your_map.yaml file at the location you defined. If you wish to use this map in navstack move it to the folder from which you call the maps and change the name of the map.yaml file in move_base.launch to your_map.yaml.</p> <p>If you want to launch all commands together, you can just type</p> <pre><code>roslaunch helmoro_description gmapping_helmoro.launch\n</code></pre> <p>However, calling this custom launch file, you still need to run</p> <pre><code>rosrun map_server map_saver -f &lt;location and name of your_map&gt;\n</code></pre> <p>when you're finished.</p>"},{"location":"software_ros1/06_algorithms/#configuration","title":"Configuration","text":"<p>Gmapping can be customized using parameters. The launch file gmapping.launch, which is saved under helmoro_description/launch/gmapping calls the gmapping node with customized parameters for Helmoro. helmoro_gmapping.launch in turn calls gmapping.launch together with helmoro.launch.</p>"},{"location":"software_ros1/06_algorithms/#limitations","title":"Limitations:","text":"<p>The gmapping algorithm only takes uses laser scan data coming from a horizontally mounted lidar. The RGB-D camera cannot be used for this task. Therefore, only objects that cross the \"detection-plane\" height of the lidar will be noticed. Also, highly reflective or transparent objects will not be detected properly using a lidar and will therefore not be written into the map.</p>"},{"location":"software_ros1/06_algorithms/#troubleshooting","title":"Troubleshooting","text":"<p>A problem often encountered when mapping feature poor environments such as long hallways, is that when driving the robot forward, it can skip back to the place it was before on the map since to gmapping, the features look alike. For this problem, it is advised to tweak the parameters so that gmapping puts more trust into the odometry information it gets. Have a look at Bad maps produced by gmapping and Repeated sideways jumps on ROS answer for further discussion on the topic.</p> <p>For further information on the usage of gmapping head to: gmapping ROS Wiki and slam_gmapping Tutorial</p>"},{"location":"software_ros1/06_algorithms/#autonomous-navigation-using-the-navigation-stack","title":"Autonomous Navigation using the Navigation Stack","text":"<p>72-autonomous-navigation-using-the-navigation-stack For a good overview and detailed description head to: Navigation Stack ROS wiki and Robot Setup</p>"},{"location":"software_ros1/06_algorithms/#concept","title":"Concept","text":"<p>The following image shows a conceptual flowchart of the Navigation Stack. Note that the stack subscribes to exactly the blue topics that are provided by Helmoro.</p> <p></p> <p>In short, a global goal (<code>/move_base_simple/goal</code>) can be sent to the navigation stack, which is interpreted by the global_planner. Taking into account information from the local and global costmap it will generate a path from the robot's current position to the global goal. This path is then interpreted by the local planner, which in turn publishes the movement command for the robot.</p>"},{"location":"software_ros1/06_algorithms/#move_base","title":"move_base","text":"<p>move_base controls the different packages needed for autonomous navigation including a global and a local_costmap depending on costmap_2d, a global and a local_planner and recovery behaviors. All the used packages for the navigation stack can be individually tuned using parameters. Refer to the links of the individual packages for further information.</p>"},{"location":"software_ros1/06_algorithms/#map_server","title":"map_server","text":"<p>If you want to hand over a global map to the Navigation Stack (created by gmapping), you can use the map_server by handing over the yaml file for the map you want to hand over. Note that the yaml file describes the location of the pgm file of your map.</p>"},{"location":"software_ros1/06_algorithms/#amcl","title":"AMCL","text":"<p>AMCL, short for Adaptive Monte Carlo Localization, takes in laser scans, odometry, tf and map provided by the map server and computes a pose estimate of the base_link w.r.t. the global map frame and publishes it onto <code>amcl_pose</code> and <code>/tf</code> topics. To do so, AMCL constantly compares information from the robot's odometry and the alignment of the laser scans with the global map. AMCL can be finetuned using parameters. For further information on AMCL, head to the AMCL ROS wiki.</p>"},{"location":"software_ros1/06_algorithms/#configuration-for-helmoro","title":"Configuration for Helmoro","text":"<p>The internal package helmoro_2dnav includes all the launch and parameter files used to for the specific application of the navigation stack to Helmoro.</p> <p>The main launch file is <code>move_base.launch</code>, which calls all the actions needed and reads in the parameters specified in the different parameter files. It calls move_base:</p> <pre><code>&lt;node pkg=\"move_base\" type=\"move_base\" respawn=\"false\" name=\"move_base\" output=\"screen\"&gt;\n</code></pre> <p>as well as the map_server:</p> <pre><code>&lt;node name=\"map_server\" pkg=\"map_server\" type=\"map_server\" args=\"$(find helmoro_2dnav)/helmoro_maps/mymap.yaml\"/&gt;\n</code></pre> <p>and AMCL:</p> <pre><code>&lt;include file=\"$(find helmoro_2dnav)/amcl_helmoro.launch\" /&gt;\n</code></pre> <p>Further, the parameters used for Helmoro are specified in the following files:</p> <ul> <li>common_costmap_params: parameters for both local and global costmap</li> <li>local_costmap_params: parameters for the local costmap</li> <li>global_costmap_params: parameters for the global costmap</li> <li>base_local_planner_params: parameters for the local planner</li> <li>global_planner_params: parameters for the global planner</li> </ul> <p>In addition, all maps used for the map server are saved in the folder helmoro_2dnav/helmoro_maps.</p>"},{"location":"software_ros1/06_algorithms/#run_1","title":"Run","text":"<p>To run the navigation stack either set the value in the helmoro.launch file of 'use_nav_stack' to 'true' or type the following command into your terminal: you can either call helmoro.launch and move_base.launch seperately:</p> <pre><code>roslaunch helmoro_description helmoro.launch\nroslaunch helmoro_2dnav move_base.launch\n</code></pre> <p>or simply launch nav_helmoro.launch, which calls both above launch files together.</p> <pre><code>roslaunch helmoro_description nav_helmoro.launch\n</code></pre> <p>The navigation stack is easiest used in combination with RViZ where the different maps and paths of Helmoro's world can be visualized. You can send a goal using the <code>2D Nav Goal</code> button or place Helmoro at a distinct position in your map with the <code>2D Pose Estimate</code> button. The settings to visualize the aspects of the navigation stack are saved in the default rviz config file under helmoro_description/rviz/rviz_config.rviz Head to Nav Stack with RViz for further documentation on this topic.</p> <p>You can also send goals and pose estimates directly in the terminal by typing:</p> <pre><code>rostopic pub -1 /move_base_simple/goal\n</code></pre> <p>or</p> <pre><code>rostopic pub -1 /initialpose\n</code></pre> <p>and tab-complete respectively.</p> <p>If you repeatedly want to start Helmoro from the same position in your map and only want to go through the task of setting a matching map position for Helmoro in RViZ once, it's a good practise to first listen to the topic <code>/intitialpose</code> (<code>rostopic echo /initialpose</code>) in order to acquire the coordinates and to be able to set them through the terminal for the next start.</p> <p>Another option to specify the start position of Helmoro is to specify it in the parameters <code>initial_pose_x</code>, <code>initial_pose_y</code> and <code>initial_pose_a</code> for AMCL. Currently, a launch file called amcl_helmoro.launch is called in move_base.launch as described in configuration for helmoro.</p> <p>In order to let Helmoro localize itself, you can use the <code>/global_localization</code> service offered by AMCL by typing:</p> <pre><code>rosservice call /global_localization \"{}\"\n</code></pre> <p>If Helmoro gets stuck and can't find a way out because of so called ghost objects (objects marked that are actually free space), try the following rosservice call:</p> <pre><code>rosservice call /move_base/clear_costmaps\n</code></pre> <p>For reference on this call, have a look at the following ROS Answers</p>"},{"location":"software_ros1/06_algorithms/#tuning-the-navigation-stack","title":"Tuning the Navigation Stack","text":"<p>As mentioned above, the each functionality of the navigation stack can be finetuned using parameters. In the following, some suggestions and findings, that where made when tuning nav stack for Helmoro, on how to tune the parameters for the different functionalities are given. In addition, some useful links for tuning and troubleshooting the navigation stack are provided at the end of this subsection.</p> <p>TIP: A lot of the parameters of the navigation stack are dynamically tunable. When you run </p> <pre><code>rosrun rqt_reconfigure rqt_reconfigure\n</code></pre> <p>while your robot is running you can change many values dynamically in runtime.</p>"},{"location":"software_ros1/06_algorithms/#costmaps-in-general","title":"Costmaps in General","text":"<p>Both the local costmap and the global costmaps are two map types derived from costmap_2d, which provides a configurable structure that maintains information about where the robot should navigate in the form of an occupancy grid. The difference between the two is that the global costmap is seeded with a user-generated static map (map server) and the local costmap has a specified width and height which keeps the robot centered inside it.</p> <p>The costmaps can be configured using plugins for the different layers. The most commonly used layers are the static_layer (for the global costmap), the obstacle layer (tracks obstacles), inflation layer (lays inflation around obstacles). Obviously, the static layer should only be present in the global costmap. The local costmap in turn should have the parameter \"rolling window\" set to true. Have a look at global_costmap_params and local_costmap_params.</p>"},{"location":"software_ros1/06_algorithms/#common_costmap_params","title":"common_costmap_params","text":"<p>important obstacle_layer parameters:</p> <ul> <li><code>max_obstacle_height</code>): The maximum height of any obstacle to be inserted into the costmap in meters. This parameter should be set to be slightly higher than the height of your robot. Can be over-ridden on a per-sensor basis.</li> <li><code>obstacle_range</code>: Maximum distance from the robot at which an obstacle will be inserted into the cost map in meters. Can be over-ridden on a per-sensor basis. Have a look at the sensor specs to define this parameter.</li> <li><code>raytrace_range</code>: The default range in meters at which to raytrace out obstacles from the map using sensor data. Set this parameter to a slightly higher value than obstacle_range to avoid ghost objects. Have a look at the sensor specs to define this parameter.</li> </ul> <p>Further, you can define several sensor sources that are taken into account such as our rgb-d camera and lidar which in turn are configurable. Note that is important to set the parameter <code>inf_is_valid</code> to true for our lidar. The rplidar returns inf for invalid measurements for example when there is no object where the laser beam can reflect on in its range. This parameter will help raytrace objects from the costmap even if the laser beam is not reflected properly in a certain direction.</p> <p>important inflation_layer parameters:</p> <ul> <li><code>inflation_radius</code>: radius in meters to which the map inflates obstacle cost values. This parameter should be bigger that the circumscribed radius of the robot in order to guarantee robust navigation.</li> <li><code>cost_scaling_factor</code>: rate ad which the exponential decay function of cost values away from an object drops. A higher value for this parameter will result in decreased cost values.</li> </ul>"},{"location":"software_ros1/06_algorithms/#base_local_planner_params","title":"base_local_planner_params","text":"<p>Velocity and Acceleration: It is important to set the minimal velocities to a value that lets Helmoro overcome friction and the maximal velocities so that Helmoro is able to reach them. The easiest way to find the mathcing values for these parameters is to start the helmoro.launch file (without the navigation stack) and send a <code>/cmd_vel</code> to Helmoro directly through the terminal using</p> <pre><code>rostopic pub -r 50 /cmd_vel\n</code></pre> <p>and tab-complete. Simultaneously rqt_plot can be started and the desired topics can be displayed so that one can easily see how well Helmoro tracks a given <code>/cmd_vel</code>. For linear motion you would want to display <code>/odom/twist/twist/linear/x</code> and <code>/cmd_vel/linear/x</code>, for angular motion you would want to display <code>/odom/twist/twist/angular/z</code> and <code>/cmd_vel/angular/z</code>.</p> <p>Goal distance tolerance:</p> <ul> <li><code>xy_goal_tolerance</code>: Tolerance in meters in x and y direction for a goal to be considered reached.</li> <li><code>yaw_goal_tolerance</code>: Tolerance in radians in yaw orientation for a goal to be considered reached.</li> </ul> <p>Setting these parameters, the minimal linear and angular velocities mentioned above should be considered. A robot with a higher minimal velocity should be given a higher tolerance on its goal.</p> <p>Forward simulation:</p> <ul> <li><code>sim_time</code>: Defines the amount of time to forward simulate trajectories in seconds. This largely influences the behaviour of the robot especially when its close to reaching its goal. From experience, it is advised to keep this parameter between 1 and 2 seconds for Helmoro. The longer the value for <code>sim_time</code>, the higher the computational load becomes. However, setting <code>sim_time</code> too low, can result in limited performance especially when the robot needs to pass a narrow path. Another point is that forwardsimulated trajectories simulated are scored by their endpoints. Therefore, the <code>sim_time</code> parameter can have a large effect on how the robot behaves especially when its close to reaching its goal. For example if <code>min_vel_x</code> is set to 0.1m/s and <code>sim_time</code> is set to 5s, any trajectory with positive x velocity will move at least 0.5 meters forward. If now the goal tolerance is too low, in place rotations will score more favourably than a simple linear motion. A reasonable suggestion that can be looked up on this ROS wiki page about tuning in section 3, is to set the parameters in the following fashion:</li> <li><code>min_vel_x * sim_time &lt; 2 * xy_goal_tolerance</code></li> <li><code>min_in_place_vel_theta * sim_time &lt; 2 * yaw_goal_tolerance</code></li> </ul> <p>Bear in mind that a lot of parameters depend on each other. For example when lowering your value for sim_time, you may want to lower your value for path_distance_bias a little.</p>"},{"location":"software_ros1/06_algorithms/#global_planner_params","title":"global_planner_params","text":"<p>The three most important parameters that influence the fashion how the global path is planned obtaining costmap information are <code>lethal_cost</code>, <code>neutral_cost</code> and <code>cost_factor</code>. These parameters have been left to default for Helmoro. For your reference, head to Navguide for a good explanation on these parameters.</p>"},{"location":"software_ros1/06_algorithms/#useful-links","title":"Useful Links","text":"<p>In order to get an idea on how to tune parameters for the navigation stack, have a look at the following links:</p> <p>Guides:</p> <ul> <li> <p>Navguide</p> </li> <li> <p>Navigation Tuning Guide</p> </li> </ul> <p>Examples:</p> <ul> <li> <p>Husarion Docs</p> </li> <li> <p>caltech_samaritan</p> </li> </ul> <p>Troubleshooting:</p> <ul> <li>ROS wiki troubleshooting</li> </ul>"},{"location":"software_ros1/06_algorithms/#issues-concerning-the-navigation-stack","title":"Issues concerning the Navigation Stack","text":"<p>The Issues can be found under the Issues of the repository</p>"},{"location":"software_ros1/06_algorithms/#autonomous-slam-using-explore_lite","title":"Autonomous SLAM using explore_lite","text":""},{"location":"software_ros1/06_algorithms/#concept_1","title":"Concept","text":"<p>Helmoro can do the task of building a map autonomously using a ROS package called explore_lite.This package provides greedy frontier-based exploration. When node is running, robot will greedily explore its environment until no frontiers could be found. The following picture shows an intuitive overview of how the package works.</p> <p></p> <p>explore_lite sends different goal positions to the navigation stack considering the continuously updated map from gmapping or the costmap from move_base. Note that you can use both. Depending on your environment you may achieve better results with either SLAM map or costmap published by move_base. Advantage of move_base costmap is the inflation which helps to deal with some very small unexplorable frontiers. When you are using a raw map produced by SLAM you should set the min_frontier_size parameter to some reasonable number to deal with the small frontiers.</p>"},{"location":"software_ros1/06_algorithms/#run_2","title":"Run","text":"<p>In order to Run the autonomous mapping task, run Helmoro with the Navigation Stack using gmapping instead of amcl. Also, make sure not to provide a map using the map_server. To do so, you can call the custom launch file for Helmoro called explore_helmoro.launch</p> <pre><code>roslaunch helmoro_description explore_helmoro.launch\n</code></pre> <p>Note that this launch file includes an argument <code>use_movebase_costmap</code>. If set to false, the launch file will call expore.launch, the launch file which will make explorelite use map information from gmapping for planning. If set to true, the launch file will call expore_costmap.launch, the launch file which will make explore_lite use map information from the move_base costmap for planning. Both explore.launch and explore costmap.launch are saved under /helmorodescription/launch/explore_lite/ and hold custom parameters for the usage of explore_lite with Helmoro. If using explore_costmap.launch, it is very important to set the parameter <code>track_unknown_space</code> to true in common_costmap_params.yaml for the navigation stack.</p> <p>Head to explore_lite wiki for futher information. For an example and some helpful instructions, head to Husarion Docs.</p>"},{"location":"software_ros2/architecture/","title":"Software Architecture","text":""},{"location":"software_ros2/architecture/#high-level-overview","title":"High Level Overview","text":"<p>The following flowchart shows a high-level view of the communication in-between our packages when running the system on the robot. Naming convention in our repository may vary, as we show here the underlying algorithms of our packages, instead of the packages named by our internal company convention. In case of running the HelMoRo repository as a simulation, the four lefternmost hardware nodes are replaced by a single gazebo_ros bridge, which handles communication between ROS and the gazebo simulation engine. The internal packages are briefly explained in sections helmoro_common, helmoro_real and helmoro_sim. External Packages are explained in section External Packages. </p> <p></p>"},{"location":"software_ros2/architecture/#helmoro_common","title":"helmoro_common","text":"<p>In the following, each package of the Helmoro ROS architecture is explained shortly.</p>"},{"location":"software_ros2/architecture/#bringup","title":"bringup","text":"<ul> <li>manages the launch process of the HelMoRo</li> <li>manages the launch process of RVIZ</li> </ul>"},{"location":"software_ros2/architecture/#control","title":"control","text":"<ul> <li>stores parameters for diff drive controller and joint state broadcaster.</li> </ul>"},{"location":"software_ros2/architecture/#description","title":"description","text":"<ul> <li>stores URDF and meshes</li> <li>publishes static transforms</li> </ul>"},{"location":"software_ros2/architecture/#state_estimation","title":"state_estimation","text":"<ul> <li>uses robot_localization in the background</li> <li>combines wheel odometry and IMU information with an EKF</li> <li>publishes transform between HelMoRo and odom frame</li> </ul>"},{"location":"software_ros2/architecture/#slam","title":"slam","text":"<ul> <li>uses slam_toolbox in the background</li> <li>combines lidar scans and odometry pose to create a map of the environment and localizes HelMoRo within</li> <li>publishes transform between map and odom frame</li> </ul>"},{"location":"software_ros2/architecture/#helmoro_real","title":"helmoro_real","text":""},{"location":"software_ros2/architecture/#bringup_1","title":"bringup","text":"<ul> <li>manages the launch process of packages interfacing with IMU, camera, LIDAR and motors</li> </ul>"},{"location":"software_ros2/architecture/#motors","title":"motors","text":"<ul> <li>ROS2 wrapper for the motor controllers</li> <li>converts motor states into wheel odometry</li> <li>converts robot velocity commands into motor commands</li> </ul>"},{"location":"software_ros2/architecture/#wiring-options","title":"Wiring Options","text":"Checklist Wiring - Wire both RoboClaws to the Jetson Nano SBC via Micro-USB to Micro-USB cable. Setting - Connect one RoboClaw to PC via USB and open it with the downloaded BasicmicroMotionStudio - Don\u2019t set any of the two RoboClaws to USB-TTL Relay Mode - Set an address for each RoboClaw in the General Settings. Note for this wiring, the addresses can be equal since ports are different (/dev/ttyACM0 and /dev/ttyACM1 in Linux) - Set Baudrate you would like to use in the General Settings. - Configure the PID values of the RoboClaws if not yet done. - Don\u2019t forget to Device \u2192 Write Settings in the top left corner before disconnecting your RoboClaw."},{"location":"software_ros2/architecture/#helmoro_sim","title":"helmoro_sim","text":""},{"location":"software_ros2/architecture/#bringup_2","title":"bringup","text":"<ul> <li>manages the launch process of the gazebo simulation and spawns the robot</li> </ul>"},{"location":"software_ros2/architecture/#gazebo_tools","title":"gazebo_tools","text":"<ul> <li>contains world files</li> <li>starts the ros-gazebo bridge</li> </ul>"},{"location":"software_ros2/architecture/#helmoro_operations","title":"helmoro_operations","text":""},{"location":"software_ros2/architecture/#joymanager","title":"joymanager","text":"<ul> <li>interprets joystick commands from Logitech Wireless joystick F710 controller</li> <li>scales joystick commands to desired linear and angular velocities</li> <li>publishes of velocity commands</li> </ul>"},{"location":"software_ros2/architecture/#navigation","title":"navigation","text":"<ul> <li>uses navigation2 in the background</li> <li>launches nodes for local and global costmap generation</li> <li>launches nodes for recovery behaviour, planning and trajectory following</li> </ul>"},{"location":"software_ros2/architecture/#external-packages","title":"External Packages","text":""},{"location":"software_ros2/architecture/#camera","title":"Camera","text":"<p>The OrbbecSDK ROS2 Wrapper provides integration of Orbbec cameras with ROS 2 environment. It supports ROS2 Foxy, Humble, and Jazzy distributions. Helmoro's camera, the Astra Pro Plus, is EoL. We created our own fork to fix a bug caused by non-existing intrinsic parameters.</p>"},{"location":"software_ros2/architecture/#imu","title":"IMU","text":"<p>The bno055 package is a community created packages for interfacing with the IMU Bosch BNO055 IMU.</p>"},{"location":"software_ros2/architecture/#lidar","title":"LIDAR","text":"<p>The rplidar_ros packages is provided by the LIDAR manufacturer Slamtec. It supports ROS1 and ROS2.</p>"},{"location":"software_ros2/installation/","title":"Installation","text":""},{"location":"software_ros2/installation/#installation-on-the-pc","title":"Installation on the PC","text":"<ol> <li> <p>Install ROS Humble</p> </li> <li> <p>Create a workspace and clone our repository. For better readability we created the workspace in this guide within the home directory and named the workspace ros2_ws. But feel free to choose another directory and workspace name.</p> <pre><code>mkdir ~/ros2_ws/src\ncd ~ros2_ws/src\ngit clone https://github.com/Helbling-Technik/HelMoRo-software-ROS2.git\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>cd ~/ros2_ws\nsudo apt-get update\nrosdep install --from-path src -yi\n</code></pre> </li> <li> <p>Source ROS and build the HelMoRo software package</p> <pre><code>source /opt/ros/humble/setup.bash\ncd ~/ros2_ws\ncolcon build --symlink-install\n</code></pre> </li> <li> <p>Your folder structure should now look like this     <pre><code>~/ros2_ws\n\u251c\u2500\u2500 build\n\u251c\u2500\u2500 install\n\u251c\u2500\u2500 log\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 HelMoRo-software-ROS2\n</code></pre></p> </li> </ol>"},{"location":"software_ros2/installation/#installation-on-the-robot","title":"Installation on the robot","text":"<ol> <li> <p>Install ROS Humble</p> </li> <li> <p>Create a workspace and clone our repository. For better readability we created the workspace in this guide within the home directory and named the workspace ros2_ws. But feel free to choose another directory and workspace name.</p> <pre><code>mkdir ~/ros2_ws/src\ncd ~ros2_ws/src\ngit clone https://github.com/Helbling-Technik/HelMoRo-software-ROS2.git\n</code></pre> </li> <li> <p>Clone the repo for communication with the lidar, IMU and camera</p> <pre><code>git clone https://github.com/flynneva/bno055.git\ngit clone -b ros2 https://github.com/Slamtec/rplidar_ros.git\ngit clone https://github.com/Helbling-Technik/HelMoRo_OrbbecSDK_ROS2.git\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>cd ~/ros2_ws\nsudo apt-get update\nrosdep install --from-path src -yi\n</code></pre> </li> <li> <p>Your folder structure should now look like this     <pre><code>~/ros2_ws\n\u251c\u2500\u2500 build\n\u251c\u2500\u2500 install\n\u251c\u2500\u2500 log\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 bno055\n    \u251c\u2500\u2500 HelMoRo_OrbbecSDK_ROS2\n    \u251c\u2500\u2500 HelMoRo-software-ROS2\n    \u2514\u2500\u2500 rplidar_ros\n</code></pre></p> </li> </ol>"},{"location":"software_ros2/troubleshooting/","title":"Troubleshooting","text":""},{"location":"software_ros2/troubleshooting/#network","title":"Network","text":"<p>In case you can't receive or send messages over your network, go through these checks:</p> <ol> <li>Do your robot and computer have the same ROS_DOMAIN_ID?</li> <li>Does your firewall block communication? Maybe you need to open ports?     <pre><code>sudo ufw allow in proto udp to 224.0.0.0/4\nsudo ufw allow in proto udp from 224.0.0.0/4\n</code></pre></li> <li>Is multicasting enabled in your network interfaces? Is multicasting enabled in your router? Check by using the multicast package.</li> </ol>"},{"location":"software_ros2/troubleshooting/#motors","title":"Motors","text":"<p>In case you are getting errors from the helmoro_motor_controls and the Roboclaw Motor Controllers are not working, go through the following quick checks:</p> <ol> <li>Check if the port name of both Roboclaws appear when plugin in, the USB by typing <code>ls /dev/ttyACM*</code></li> <li>Check if you have the authority to write to this port. Otherwise type <code>chmod 666 &lt;portname&gt;</code> in order to add the authority.</li> <li>Also, when connecting the motors with two USB cables, it can happen that the portnames of the left and the right roboclaw motor controller swap (<code>/dev/ttyACM0</code> &lt;-&gt; <code>/dev/ttyACM1</code>). Since, to this point their USB ports are not fixed. If this happens, simply swap the two addresses for the left and the right controller specified in the param file.</li> </ol>"},{"location":"software_ros2/usage_guide/","title":"Usage Guide","text":"<p>When opening a new terminal always ensure that you sourced ROS.      <pre><code>source /opt/ros/humble/setup.bash\n</code></pre></p> <p>Alternatively you can also enable autonomous sourcing on terminal startup, by adding it to your .bashrc file.     <pre><code>echo \"source /opt/ros/humble/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre></p> <p>Also always source your workspace when using a fresh terminal or after a change of any built pkgs.     <pre><code>source ~/ros2_ws/install/setup.bash\n</code></pre></p>"},{"location":"software_ros2/usage_guide/#start-up","title":"Start-Up","text":""},{"location":"software_ros2/usage_guide/#starting-the-simulation","title":"Starting the simulation","text":"<ol> <li>Build the packages.     <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\n</code></pre></li> <li> <p>Source the workspace.     <pre><code>source install/local_setup.bash\n</code></pre></p> </li> <li> <p>Start the simulation.     <pre><code>ros2 launch helmoro_sim_bringup helmoro_sim_launch.py\n</code></pre></p> </li> </ol>"},{"location":"software_ros2/usage_guide/#starting-the-robot","title":"Starting the Robot","text":"<ol> <li> <p>SSH into the robot.     <pre><code>ssh $(username of robot)@$(ip of robot)\n</code></pre></p> </li> <li> <p>Build the packages.     <pre><code>cd ~/ros2_ws\ncolcon build --symlink-install\n</code></pre></p> </li> <li> <p>Source the workspace.     <pre><code>source install/local_setup.bash\n</code></pre></p> </li> <li> <p>Start the robot.     <pre><code>ros2 launch helmoro_real_bringup helmoro_launch.py\n</code></pre></p> </li> <li> <p>For mapping visualization and camera streaming start RVIZ on the computer.     <pre><code>ros2 launch helmoro_common_bringup rviz_launch.py\n</code></pre></p> </li> </ol>"},{"location":"software_ros2/usage_guide/#controlling-the-robot","title":"Controlling the Robot","text":"<p>The robot can be controlled in multiple ways. The way we set it up, is to have operations packages within the folder helmoro_operation that use the topic /cmd_vel as an interface to control HelMoRo. In this example we created two packages. The joy control package and the navigation package. For controlling the robot with a joystick, use the joy control package. For autonomous navigation use the navigation package.</p>"},{"location":"software_ros2/usage_guide/#joy-control","title":"Joy Control","text":"<p>In the simplest case one can drive Helmoro around using a joystick. In our case we used a Logitech joystick, which we connected to the laptop over Bluetooth. The left 'LT' and right triggers 'LT' accelerate and decellerate in x-direction respectively, and the left digital stick controls the rotation.</p> <p>For this one needs to just start up either the simulation or the robot.</p> <p>Before starting up the joystick make sure that the joystick is connected via the usb receiver to the computer. Also at the backside of the logitech controller you'll find a switch. Shift the switch to 'X' for XInput instead of 'D' for DirectInput such that floating point values will be broadcasted. Also make sure to press the 'mode'-button such that the LED next to the 'mode'-button lights up. This is necessary for the correct mapping of the inputs. Secondly one needs to actually start the joystick node on the computer which is connected to the same network. Afterwards start the joystick manager.</p> <pre><code>ros2 launch helmoro_joy_control joy_control.launch\n</code></pre> <p>Press the logitech button to wake up the controller, then press the 'LT' and 'RT' once to fully start the broadcasting of the velocity. To move forward use the 'RT' button while using the 'LT' Button to  move backwards. The left and right buttons on the left most (digital) joystick can be used to control the rotation.</p>"},{"location":"software_ros2/usage_guide/#autonomous-navigation","title":"Autonomous Navigation","text":"<p>HelMoRo is able to navigate in a given space using the ROS Navigation Stack avoiding static and dynamic obstacles. Similarly HelMoRo can also navigate a unknown spaces avoiding static and dynamic obstacles while simulatinously mapping it by inluding the ROS SLAM stack too. In autonomous navigation mode it is possible to steer HelMoRo by sending PoseStamped msgs to the topic /goal_pose. In RVIZ this can be done by using the 2D Goal Pose functionality in the top bar.</p> <p></p> <p>Autonomous navigation is included by default in the helmoro simulation and robot startup. If you want to use the navigation pkg without the robot, start it with.</p> <pre><code>ros2 launch helmoro_navigation nav_2.launch\n</code></pre> <p>More information can be found in the chapter Autonomous Navigation using the Navigation Stack.</p>"}]}